const DOCUMENATATION: &str = "reflet-asm, an assembler for the Reflet architecture.

Usage:
    reflet-asm <input-file> <options> -o <output-file>
    reflet-asm -help

Options:
  * -no-prefix: does not put the 'ASRM' prefix at the beginning of the output
    file.
  * -word-size 8/16/32/64: indicate the size of registers in the target CPU.
  * -no-stack-init : does not initialize the stack pointer. When not used, the
    stack pointer is by default initialized to just after the program.
  * -set-stack-to xxx : set the stack pointer to the address given just after
    the flag. Incompatible with -no-stack-init. Defaults to 0 when not set.
  * -start-addr xxx : tell the linker that the code should start at the given
    address.
  * -ignore-start : if set, the program will not start at the \"start\" label
    but at the beginning of the input file.
  * -ignore-compatibility-runtime: do not write the code that edit the status
    register to make the binary works on larger processors.
  * -label-dump: if set, a dump of all labels will be printed just before
    linkage.
  * -D <name>=<definition>: defines the macro `name` with te=he current
    definition. It will be a flat define macro.";

/// State of all the command line options.
pub struct Arguments {
    /// Does an help message needs to be printed?
    pub help: bool,

    /// Path of the input file
    pub input: String,

    /// Path of the output file
    pub output: String,

    /// Word size in bits
    pub word_size: usize,

    /// Does the stack needs to be set?
    pub set_stack: bool,

    /// Address of the first generated byte
    pub start_addr: usize,

    /// Stack address to be set, "" is the default value
    pub stack_addr: String,

    /// Should we start from the beginning instead of from the start label
    pub ignore_start: bool,

    /// Should we remove the 'ASRM' prefix?
    pub no_prefix: bool,

    /// Should we remove the SR initialization
    pub no_compatibility: bool,

    /// Should we do a label dump ?
    pub label_dump: bool,

    /// List of -D defines
    pub defines: Vec<(String, String)>,
}

use macro_asm_builder::utils::format_string_into_number;

/// Parse the arguments and fill and argument struct. Return None in case of
/// invalid arguments
fn read_args() -> Option<Arguments> {
    let mut i = 1;
    let args: Vec<String> = std::env::args().collect();
    macro_rules! not_last_arg {
        () => {
            {
                let last_one = i == args.len() - 1;
                if last_one {
                    eprintln!("Error, {} flag should take an argument.", args[i]);
                    return None;
                }
                i += 1; 
            }
        }
    }

    let mut ret = Arguments{
        help: false,
        input: "".to_string(),
        output: "".to_string(),
        word_size: 0,
        set_stack: true,
        stack_addr: "".to_string(),
        start_addr: 0,
        ignore_start: false,
        no_prefix: false,
        no_compatibility: false,
        label_dump: false,
        defines: vec![],
    };

    for arg in &args {
        match arg.as_str() {
            "-h" | "-help" | "--help" | "help" => {
                ret.help = true;
                return Some(ret);
            },
            _ => {},
        }
    }

    while i < args.len() {
        match args[i].as_str() {
            "-word-size" => {
                not_last_arg!();
                match usize::from_str_radix(&args[i], 10) {
                    Ok(num) => {
                        ret.word_size = num;
                    },
                    Err(_) => {
                        eprintln!("Error, -word-size flag should take a number as argument.");
                        return None;
                    },
                }
            },
            "-o" => {
                not_last_arg!();
                ret.output = args[i].clone();
            },
            "-set-stack-to" => {
                not_last_arg!();
                ret.stack_addr = args[i].clone();
            },
            "-start-addr" => {
                not_last_arg!();
                match format_string_into_number(&args[i]) {
                    Some((num, false)) => {
                        ret.start_addr = num.try_into().unwrap();
                    },
                    None | Some((_, true)) => {
                        eprintln!("Error, -start-addr flag should take a positive number as argument.");
                        return None;
                    },
                }
            },
            "-D" => {
                not_last_arg!();
                if let Some(definition) = process_define(&args[i]) {
                    ret.defines.push(definition);
                } else {
                    return None;
                }
            }
            "-no-stack-init" => {
                ret.set_stack = false;
            },
            "-no-prefix" => {
                ret.no_prefix = true;
            },
            "-ignore-start" => {
                ret.ignore_start = true;
            },
            "-label-dump" => {
                ret.label_dump = true;
            },
            "-ignore-compatibility-runtime" => {
                ret.no_compatibility = true;
            }
            _ => {
                if ret.input == "" {
                    ret.input = args[i].clone();
                } else {
                    eprintln!("Error, only a single input file can be given.");
                    return None;
                }
            },
        }
        i += 1;
    }
    if args.len() == 1 {
        ret.help = true;
    }
    Some(ret)
}

/// Read the argument to the -D flag and try to process it.
fn process_define(arg: &str) -> Option<(String, String)> {
    let chars = arg.chars().collect::<Vec<char>>();
    let mut name = String::new();
    let mut index = 0;
    loop {
        if index == chars.len() {
            break;
        }
        if chars[index] == '=' {
            index += 1;
            break;
        }
        name.push(chars[index]);
        index += 1;
    }
    let mut value = String::new();
    for i in index..chars.len() {
        value.push(chars[i]);
    }
    if name == "" || value == "" {
        eprintln!("Error, argument defines should be in the format `-D <name>=<value>`.");
        None
    } else {
        Some((name, value))
    }
}

/// Checks that the arguments are coherent and return true if they are and false
/// otherwise.
fn check_arguments(arg: &Arguments) -> bool {
    if arg.help {
        true
    } else if arg.input == "" {
        eprintln!("Error, an input file must be specified.");
        false
    } else if arg.output == "" {
        eprintln!("Error, an output file must be specified.");
        false
    } else {
        true
    }
}

/// Read the argument and return an Argument struct if they are valid and
/// coherent. Otherwise, return None and print error messages.
pub fn parse_args() -> Option<Arguments> {
    match read_args() {
        Some(arg) => {
            if check_arguments(&arg) {
                if arg.help {
                    println!("{}", DOCUMENATATION);
                }
                Some(arg)
            } else {
                None
            }
        },
        None => None,
    }
}

