/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "objsrc/reflet-asm.c" -x none -fwrapv -fno-strict-aliasing -g -lm -o "objsrc/reflet-asm" */
/* Compile hash: 3cbaYcTcgpcMhxGBz2JhraPudBdA */
/* ------------------------------ DIRECTIVES -------------------------------- */
/* Disable some warnings that the generated code can trigger. */
#if defined(__clang__) && __clang_major__ >= 3
  #pragma clang diagnostic ignored "-Wtype-limits"
  #pragma clang diagnostic ignored "-Wwrite-strings"
  #pragma clang diagnostic ignored "-Wunused"
  #pragma clang diagnostic ignored "-Wunused-parameter"
  #pragma clang diagnostic ignored "-Wmissing-field-initializers"
  #pragma clang diagnostic ignored "-Wparentheses-equality"
  #pragma clang diagnostic ignored "-Wtautological-compare"
  #ifndef __cplusplus
    #pragma clang diagnostic ignored "-Wmissing-braces"
    #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
    #pragma clang diagnostic error   "-Wimplicit-function-declaration"
    #pragma clang diagnostic error   "-Wimplicit-int"
  #else
    #pragma clang diagnostic ignored "-Wnarrowing"
  #endif
#elif defined(__GNUC__) && __GNUC__ >= 5
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wwrite-strings"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #pragma GCC diagnostic ignored "-Wunused-value"
  #pragma GCC diagnostic ignored "-Wunused-variable"
  #pragma GCC diagnostic ignored "-Wunused-function"
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #ifndef __cplusplus
    #pragma GCC diagnostic ignored "-Wmissing-braces"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
    #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
  #else
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
#endif
#if defined(_WIN32) && !defined(_CRT_SECURE_NO_WARNINGS)
  #define _CRT_SECURE_NO_WARNINGS
#endif
/* Macro used to perform compile-time checks. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_STATIC_ASSERT _Static_assert
#elif __cplusplus >= 201103L
  #define NELUA_STATIC_ASSERT static_assert
#else
  #define NELUA_STATIC_ASSERT(x, y)
#endif
/* Macro used to get alignment of a type. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_ALIGNOF _Alignof
#elif __cplusplus >= 201103L
  #define NELUA_ALIGNOF alignof
#elif defined(__GNUC__)
  #define NELUA_ALIGNOF __alignof__
#elif defined(_MSC_VER)
  #define NELUA_ALIGNOF __alignof
#else
  #define NELUA_ALIGNOF(x)
#endif
/* Checks if Nelua and C agrees on pointer size. */
NELUA_STATIC_ASSERT(sizeof(void*) == 8 && NELUA_ALIGNOF(void*) == 8, "Nelua and C disagree on pointer size or alignment");
/* Enable 64 bit offsets for stdio APIs. */
#if !defined(_FILE_OFFSET_BITS) && __SIZEOF_LONG__ >= 8
  #define _FILE_OFFSET_BITS 64
#endif
/* Enable POSIX APIs in included headers. */
#if !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE) && !defined(_GNU_SOURCE) && !defined(_DEFAULT_SOURCE)
  #if defined(__gnu_linux__)
    #define _GNU_SOURCE
  #else
    #define _XOPEN_SOURCE 600
  #endif
#endif
#include <stdbool.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
  #define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
  #define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
  #define NELUA_INLINE inline
#else
  #define NELUA_INLINE
#endif
#include <stdint.h>
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
  #define NELUA_UNLIKELY(x) (x)
#endif
#include <stdio.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
  #define NELUA_EXTERN extern "C"
#else
  #define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
  #if __has_feature(undefined_behavior_sanitizer)
    #define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
  #endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
  NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
  #define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
  #define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
  #define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
  #define NELUA_NORETURN __declspec(noreturn)
#else
  #define NELUA_NORETURN
#endif
#define NELUA_NIL (nlniltype){}
#include <string.h>
#include <stddef.h>
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
  #define NELUA_LIKELY(x) (x)
#endif
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
  #define NELUA_MAYALIAS __attribute__((may_alias))
#else
  #define NELUA_MAYALIAS
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
  #define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __declspec(noinline)
#else
  #define NELUA_NOINLINE
#endif
/* Macro used suppress sanitizer errors when the GC is scanning. */
#if defined(__has_feature)
  #if __has_feature(address_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #elif __has_feature(memory_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_memory))
  #endif
#endif
#ifndef NELUA_GC_NO_SANITIZE
  #if defined(__SANITIZE_ADDRESS__)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #else
    #define NELUA_GC_NO_SANITIZE
  #endif
#endif
#include <setjmp.h>
#include <errno.h>
/* ------------------------------ DECLARATIONS ------------------------------ */
typedef struct nelua_span_uint8_ nelua_span_uint8_;
typedef uint8_t* nluint8_arr0_ptr;
struct nelua_span_uint8_ {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_uint8_) == 16 && NELUA_ALIGNOF(nelua_span_uint8_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE bool nelua_span_uint8__empty(nelua_span_uint8_ self);
typedef uint8_t* nluint8_ptr;
static NELUA_INLINE nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i);
static NELUA_INLINE void nelua_write_stderr(const char* msg, uintptr_t len, bool flush);
static NELUA_NORETURN void nelua_abort(void);
typedef struct nlstring nlstring;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nlstring) == 16 && NELUA_ALIGNOF(nlstring) == 8, "Nelua and C disagree on type size or align");
static void nelua_assert_line_1(bool cond, nlstring msg);
typedef void** nlpointer_ptr;
typedef struct nelua_span_pointer_ nelua_span_pointer_;
typedef void** nlpointer_arr0_ptr;
struct nelua_span_pointer_ {
  nlpointer_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_pointer_) == 16 && NELUA_ALIGNOF(nelua_span_pointer_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer_ self, uintptr_t i);
static void nelua_assert_line_2(bool cond, nlstring msg);
typedef struct nelua_GCMarkRange nelua_GCMarkRange;
typedef nelua_GCMarkRange* nelua_GCMarkRange_ptr;
struct nelua_GCMarkRange {
  uintptr_t low;
  uintptr_t high;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GCMarkRange) == 16 && NELUA_ALIGNOF(nelua_GCMarkRange) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_GCMarkRange_ nelua_span_GCMarkRange_;
typedef nelua_GCMarkRange* nelua_GCMarkRange_arr0_ptr;
struct nelua_span_GCMarkRange_ {
  nelua_GCMarkRange_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_GCMarkRange_) == 16 && NELUA_ALIGNOF(nelua_span_GCMarkRange_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_GCMarkRange_ptr nelua_span_GCMarkRange____atindex(nelua_span_GCMarkRange_ self, uintptr_t i);
static void nelua_assert_line_3(bool cond, nlstring msg);
typedef uintptr_t* nlusize_ptr;
typedef struct nelua_span_usize_ nelua_span_usize_;
typedef uintptr_t* nlusize_arr0_ptr;
struct nelua_span_usize_ {
  nlusize_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_usize_) == 16 && NELUA_ALIGNOF(nelua_span_usize_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlusize_ptr nelua_span_usize____atindex(nelua_span_usize_ self, uintptr_t i);
static void nelua_assert_line_4(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_pointer__GCItem_ nelua_hashmapnode_pointer__GCItem_;
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__ptr;
typedef struct nelua_GCItem nelua_GCItem;
typedef void (*nelua_GCFinalizerCallback)(void*, void*);
struct nelua_GCItem {
  uintptr_t flags;
  uintptr_t size;
  void* ptr;
  nelua_GCFinalizerCallback finalizer;
  void* userdata;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GCItem) == 40 && NELUA_ALIGNOF(nelua_GCItem) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_pointer__GCItem_ {
  void* key;
  nelua_GCItem value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_pointer__GCItem_) == 64 && NELUA_ALIGNOF(nelua_hashmapnode_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_pointer__GCItem__ nelua_span_hashmapnode_pointer__GCItem__;
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__arr0_ptr;
struct nelua_span_hashmapnode_pointer__GCItem__ {
  nelua_hashmapnode_pointer__GCItem__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_pointer__GCItem__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_pointer__GCItem__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem__ self, uintptr_t i);
static void nelua_assert_line_5(bool cond, nlstring msg);
typedef nlstring* nlstring_ptr;
typedef struct nelua_span_string_ nelua_span_string_;
typedef nlstring* nlstring_arr0_ptr;
struct nelua_span_string_ {
  nlstring_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_string_) == 16 && NELUA_ALIGNOF(nelua_span_string_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlstring_ptr nelua_span_string____atindex(nelua_span_string_ self, uintptr_t i);
static void nelua_assert_line_6(bool cond, nlstring msg);
typedef struct parser_pure_line parser_pure_line;
typedef parser_pure_line* parser_pure_line_ptr;
struct parser_pure_line {
  int64_t len;
  nlstring content[50];
  nlstring raw;
};
NELUA_STATIC_ASSERT(sizeof(parser_pure_line) == 824 && NELUA_ALIGNOF(parser_pure_line) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_pure_line_ nelua_span_pure_line_;
typedef parser_pure_line* parser_pure_line_arr0_ptr;
struct nelua_span_pure_line_ {
  parser_pure_line_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_pure_line_) == 16 && NELUA_ALIGNOF(nelua_span_pure_line_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE parser_pure_line_ptr nelua_span_pure_line____atindex(nelua_span_pure_line_ self, uintptr_t i);
static void nelua_assert_line_7(bool cond, nlstring msg);
typedef struct macro_macro macro_macro;
typedef macro_macro* macro_macro_ptr;
typedef struct parser_pure_file parser_pure_file;
typedef struct nelua_vector_pure_line_ nelua_vector_pure_line_;
typedef struct nelua_GCAllocator nelua_GCAllocator;
struct nelua_GCAllocator {};
struct nelua_vector_pure_line_ {
  nelua_span_pure_line_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_pure_line_) == 24 && NELUA_ALIGNOF(nelua_vector_pure_line_) == 8, "Nelua and C disagree on type size or align");
struct parser_pure_file {
  nelua_vector_pure_line_ content;
};
NELUA_STATIC_ASSERT(sizeof(parser_pure_file) == 24 && NELUA_ALIGNOF(parser_pure_file) == 8, "Nelua and C disagree on type size or align");
struct macro_macro {
  nlstring name;
  int64_t number_of_args;
  parser_pure_file content;
};
NELUA_STATIC_ASSERT(sizeof(macro_macro) == 48 && NELUA_ALIGNOF(macro_macro) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_macro_ nelua_span_macro_;
typedef macro_macro* macro_macro_arr0_ptr;
struct nelua_span_macro_ {
  macro_macro_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_macro_) == 16 && NELUA_ALIGNOF(nelua_span_macro_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE macro_macro_ptr nelua_span_macro____atindex(nelua_span_macro_ self, uintptr_t i);
static void nelua_assert_line_8(bool cond, nlstring msg);
typedef bool* nlboolean_ptr;
typedef struct nelua_span_boolean_ nelua_span_boolean_;
typedef bool* nlboolean_arr0_ptr;
struct nelua_span_boolean_ {
  nlboolean_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_boolean_) == 16 && NELUA_ALIGNOF(nelua_span_boolean_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlboolean_ptr nelua_span_boolean____atindex(nelua_span_boolean_ self, uintptr_t i);
static void nelua_assert_line_9(bool cond, nlstring msg);
typedef struct assembler_block assembler_block;
typedef assembler_block* assembler_block_ptr;
typedef int64_t assembler_block_types;
typedef union assembler_block_union assembler_block_union;
typedef struct assembler_pure_file_block assembler_pure_file_block;
struct assembler_pure_file_block {
  parser_pure_file content;
  nlstring name;
  int64_t place;
  bool is_macro;
  nlstring dir;
};
NELUA_STATIC_ASSERT(sizeof(assembler_pure_file_block) == 72 && NELUA_ALIGNOF(assembler_pure_file_block) == 8, "Nelua and C disagree on type size or align");
typedef struct assembler_machine_code_block assembler_machine_code_block;
struct assembler_machine_code_block {
  uint8_t code;
  nlstring comment;
};
NELUA_STATIC_ASSERT(sizeof(assembler_machine_code_block) == 24 && NELUA_ALIGNOF(assembler_machine_code_block) == 8, "Nelua and C disagree on type size or align");
typedef struct assembler_alignment_directive_block assembler_alignment_directive_block;
struct assembler_alignment_directive_block {
  int64_t byte_alignment;
};
NELUA_STATIC_ASSERT(sizeof(assembler_alignment_directive_block) == 8 && NELUA_ALIGNOF(assembler_alignment_directive_block) == 8, "Nelua and C disagree on type size or align");
typedef struct assembler_constant_block assembler_constant_block;
struct assembler_constant_block {
  int64_t content;
};
NELUA_STATIC_ASSERT(sizeof(assembler_constant_block) == 8 && NELUA_ALIGNOF(assembler_constant_block) == 8, "Nelua and C disagree on type size or align");
typedef struct assembler_rawbyte_block assembler_rawbyte_block;
struct assembler_rawbyte_block {
  uint8_t content;
};
NELUA_STATIC_ASSERT(sizeof(assembler_rawbyte_block) == 1 && NELUA_ALIGNOF(assembler_rawbyte_block) == 1, "Nelua and C disagree on type size or align");
typedef struct assembler_rawbytes_block assembler_rawbytes_block;
typedef struct nelua_vector_uint8_ nelua_vector_uint8_;
struct nelua_vector_uint8_ {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_uint8_) == 24 && NELUA_ALIGNOF(nelua_vector_uint8_) == 8, "Nelua and C disagree on type size or align");
struct assembler_rawbytes_block {
  nelua_vector_uint8_ content;
};
NELUA_STATIC_ASSERT(sizeof(assembler_rawbytes_block) == 24 && NELUA_ALIGNOF(assembler_rawbytes_block) == 8, "Nelua and C disagree on type size or align");
typedef struct assembler_label_block assembler_label_block;
struct assembler_label_block {
  nlstring id;
  bool set;
};
NELUA_STATIC_ASSERT(sizeof(assembler_label_block) == 24 && NELUA_ALIGNOF(assembler_label_block) == 8, "Nelua and C disagree on type size or align");
union assembler_block_union {
  assembler_pure_file_block pure_file;
  assembler_machine_code_block machine_code;
  assembler_alignment_directive_block alignment_directive;
  assembler_constant_block constant;
  assembler_rawbyte_block rawbyte;
  assembler_rawbytes_block rawbytes;
  assembler_label_block label;
};
NELUA_STATIC_ASSERT(sizeof(assembler_block_union) == 72 && NELUA_ALIGNOF(assembler_block_union) == 8, "Nelua and C disagree on type size or align");
struct assembler_block {
  assembler_block_types type;
  assembler_block_union content;
};
NELUA_STATIC_ASSERT(sizeof(assembler_block) == 80 && NELUA_ALIGNOF(assembler_block) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_block_ nelua_span_block_;
typedef assembler_block* assembler_block_arr0_ptr;
struct nelua_span_block_ {
  assembler_block_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_block_) == 16 && NELUA_ALIGNOF(nelua_span_block_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE assembler_block_ptr nelua_span_block____atindex(nelua_span_block_ self, uintptr_t i);
static void nelua_assert_line_10(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_string__uint64_ nelua_hashmapnode_string__uint64_;
typedef nelua_hashmapnode_string__uint64_* nelua_hashmapnode_string__uint64__ptr;
struct nelua_hashmapnode_string__uint64_ {
  nlstring key;
  uint64_t value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_string__uint64_) == 40 && NELUA_ALIGNOF(nelua_hashmapnode_string__uint64_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_string__uint64__ nelua_span_hashmapnode_string__uint64__;
typedef nelua_hashmapnode_string__uint64_* nelua_hashmapnode_string__uint64__arr0_ptr;
struct nelua_span_hashmapnode_string__uint64__ {
  nelua_hashmapnode_string__uint64__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_string__uint64__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_string__uint64__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_string__uint64__ptr nelua_span_hashmapnode_string__uint64_____atindex(nelua_span_hashmapnode_string__uint64__ self, uintptr_t i);
static void nelua_assert_line_11(bool cond, nlstring msg);
typedef struct nlmulret_nlboolean_nlstring_nluint64 {
  bool r1;
  nlstring r2;
  uint64_t r3;
} nlmulret_nlboolean_nlstring_nluint64;
typedef struct nelua_hashmap_iteratorT_1 nelua_hashmap_iteratorT_1;
typedef nelua_hashmap_iteratorT_1* nelua_hashmap_iteratorT_1_ptr;
typedef nlmulret_nlboolean_nlstring_nluint64 (*function_4P5kDe2bjz7NvgfuY)(nelua_hashmap_iteratorT_1_ptr, nlstring);
typedef struct nelua_hashmap_string__uint64_ nelua_hashmap_string__uint64_;
typedef nelua_hashmap_string__uint64_* nelua_hashmap_string__uint64__ptr;
struct nelua_hashmap_iteratorT_1 {
  nelua_hashmap_string__uint64__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT_1) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT_1) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmap_string__uint64_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_string__uint64__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_string__uint64_) == 48 && NELUA_ALIGNOF(nelua_hashmap_string__uint64_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring {
  function_4P5kDe2bjz7NvgfuY r1;
  nelua_hashmap_iteratorT_1 r2;
  nlstring r3;
} nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring;
static NELUA_INLINE nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring nelua_pairs_1(nelua_hashmap_string__uint64__ptr a);
typedef nelua_GCItem* nelua_GCItem_ptr;
typedef struct nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr {
  bool r1;
  void* r2;
  nelua_GCItem_ptr r3;
} nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr;
typedef struct nelua_hashmap_iteratorT nelua_hashmap_iteratorT;
typedef nelua_hashmap_iteratorT* nelua_hashmap_iteratorT_ptr;
typedef nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr (*function_31SABs3XansuHVrNg)(nelua_hashmap_iteratorT_ptr, void*);
typedef struct nelua_hashmap_pointer__GCItem_ nelua_hashmap_pointer__GCItem_;
typedef nelua_hashmap_pointer__GCItem_* nelua_hashmap_pointer__GCItem__ptr;
struct nelua_hashmap_iteratorT {
  nelua_hashmap_pointer__GCItem__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_hashmap_pointer__GCItem_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_pointer__GCItem__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_pointer__GCItem_) == 48 && NELUA_ALIGNOF(nelua_hashmap_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer {
  function_31SABs3XansuHVrNg r1;
  nelua_hashmap_iteratorT r2;
  void* r3;
} nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer;
static NELUA_INLINE nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a);
typedef struct nlniltype {} nlniltype;
typedef struct nlniltype nltype;
static NELUA_INLINE void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static void nelua_assert_line_12(bool cond, nlstring msg);
static NELUA_INLINE void nelua_memory_zero(void* dest, uintptr_t n);
static void nelua_assert_line_13(bool cond, nlstring msg);
static NELUA_INLINE bool nelua_memory_equals(void* a, void* b, uintptr_t n);
static void nelua_assert_line_14(bool cond, nlstring msg);
static NELUA_INLINE void* nelua_memory_scan(void* src, uint8_t x, uintptr_t n);
static void nelua_assert_line_15(bool cond, nlstring msg);
static NELUA_INLINE void nelua_memory_spancopy_8(nelua_span_block_ dest, nelua_span_block_ src);
static void nelua_assert_line_16(bool cond, nlstring msg);
static NELUA_INLINE void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x);
static NELUA_NORETURN void nelua_panic_cstring(const char* s);
static NELUA_INLINE void* nelua_assert_deref(void* p);
static NELUA_INLINE uint8_t nelua_strchar_1_toupper(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isdigit(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isspace(uint8_t c);
static NELUA_INLINE uint8_t nelua_strchar_1_getbasedigit(uint8_t c);
typedef struct nlmulret_nlboolean_nlint64 {
  bool r1;
  int64_t r2;
} nlmulret_nlboolean_nlint64;
static nlmulret_nlboolean_nlint64 nelua_strconv_1_str2int(nlstring s, uint64_t base);
typedef struct NELUA_MAYALIAS nluint8_arr48 {uint8_t v[48];} nluint8_arr48;
typedef union NELUA_MAYALIAS nluint8_arr48_cast {nluint8_arr48 a; uint8_t p[48];} nluint8_arr48_cast;
NELUA_STATIC_ASSERT(sizeof(nluint8_arr48) == 48 && NELUA_ALIGNOF(nluint8_arr48) == 1, "Nelua and C disagree on type size or align");
typedef nluint8_arr48* nluint8_arr48_ptr;
static nlstring nelua_strconv_1_int2str_1(nluint8_arr48_ptr buf, int64_t x, nlniltype base);
static NELUA_INLINE uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len);
static nlstring nelua_strconv_1_int2str_2(nluint8_arr48_ptr buf, intptr_t x, nlniltype base);
static nlstring nelua_strconv_1_int2str_4(nluint8_arr48_ptr buf, assembler_block_types x, nlniltype base);
static nlstring nelua_strconv_1_int2str_6(nluint8_arr48_ptr buf, uintptr_t x, nlniltype base);
typedef struct NELUA_MAYALIAS nluint8_arr32 {uint8_t v[32];} nluint8_arr32;
typedef union NELUA_MAYALIAS nluint8_arr32_cast {nluint8_arr32 a; uint8_t p[32];} nluint8_arr32_cast;
NELUA_STATIC_ASSERT(sizeof(nluint8_arr32) == 32 && NELUA_ALIGNOF(nluint8_arr32) == 1, "Nelua and C disagree on type size or align");
typedef nluint8_arr32* nluint8_arr32_ptr;
static uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form);
static void nelua_assert_line_17(bool cond, nlstring msg);
static void nelua_assert_line_18(bool cond, nlstring msg);
static void nelua_addlenmod(nluint8_arr32_ptr form, char* lenmod, size_t lenmodsize);
static NELUA_INLINE size_t nelua_assert_bounds_nlcsize(size_t index, uintptr_t len);
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static NELUA_INLINE void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc_2(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0_2(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags);
static NELUA_INLINE void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static NELUA_INLINE void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_xalloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_NORETURN void nelua_panic_string(nlstring s);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_GCMarkRange_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_string_ nelua_GeneralAllocator_spanalloc_4(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s);
static void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCMarkRange_ s);
static void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s);
static void nelua_GeneralAllocator_spandealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s);
static nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static nelua_span_GCMarkRange_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCMarkRange_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_spanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static nelua_span_GCMarkRange_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCMarkRange_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
typedef struct nelua_sequenceimpl_string__1 nelua_sequenceimpl_string__1;
typedef nelua_sequenceimpl_string__1* nelua_sequenceimpl_string__1_ptr;
struct nelua_sequenceimpl_string__1 {
  nelua_span_string_ data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequenceimpl_string__1) == 24 && NELUA_ALIGNOF(nelua_sequenceimpl_string__1) == 8, "Nelua and C disagree on type size or align");
static nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_1(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static NELUA_INLINE uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step);
static NELUA_INLINE uintptr_t nelua_hash_long(nelua_span_uint8_ data);
static uintptr_t nelua_hash_hash_1(void* v);
static uintptr_t nelua_hash_hash_2(nlstring v);
static NELUA_INLINE uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y);
static NELUA_INLINE uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n);
static NELUA_INLINE uintptr_t nelua_roundpow2(uintptr_t n);
static void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static NELUA_NOINLINE void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_19(bool cond);
static uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static void nelua_assert_line_20(bool cond, nlstring msg);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static uintptr_t nelua_hashmap_pointer__GCItem__bucketcount(nelua_hashmap_pointer__GCItem__ptr self);
static NELUA_INLINE nelua_hashmapnode_pointer__GCItem__ptr nelua_hashmap_iteratorT__next_node(nelua_hashmap_iteratorT_ptr self, void* key);
static NELUA_INLINE nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key);
static NELUA_INLINE nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self);
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__uint64___find(nelua_hashmap_string__uint64__ptr self, nlstring key);
static NELUA_NOINLINE void nelua_hashmap_string__uint64__rehash(nelua_hashmap_string__uint64__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_21(bool cond);
static uintptr_t nelua_hashmap_string__uint64___at(nelua_hashmap_string__uint64__ptr self, nlstring key);
static void nelua_assert_line_22(bool cond, nlstring msg);
typedef uint64_t* nluint64_ptr;
static nluint64_ptr nelua_hashmap_string__uint64____atindex(nelua_hashmap_string__uint64__ptr self, nlstring key);
static nluint64_ptr nelua_hashmap_string__uint64__peek(nelua_hashmap_string__uint64__ptr self, nlstring key);
static NELUA_INLINE nelua_hashmapnode_string__uint64__ptr nelua_hashmap_iteratorT_1__next_node(nelua_hashmap_iteratorT_1_ptr self, nlstring key);
static NELUA_INLINE nlmulret_nlboolean_nlstring_nluint64 nelua_hashmap_iteratorT_1_next(nelua_hashmap_iteratorT_1_ptr self, nlstring key);
static NELUA_INLINE nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring nelua_hashmap_string__uint64____pairs(nelua_hashmap_string__uint64__ptr self);
typedef struct nelua_vector_pointer_ nelua_vector_pointer_;
typedef nelua_vector_pointer_* nelua_vector_pointer__ptr;
struct nelua_vector_pointer_ {
  nelua_span_pointer_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_pointer_) == 24 && NELUA_ALIGNOF(nelua_vector_pointer_) == 8, "Nelua and C disagree on type size or align");
static void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self);
static void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow(nelua_vector_pointer__ptr self);
static void nelua_assert_line_23(bool cond, nlstring msg);
static void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v);
static NELUA_INLINE nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos);
static void nelua_assert_line_24(bool cond, nlstring msg);
typedef struct nelua_vector_GCMarkRange_ nelua_vector_GCMarkRange_;
typedef nelua_vector_GCMarkRange_* nelua_vector_GCMarkRange__ptr;
struct nelua_vector_GCMarkRange_ {
  nelua_span_GCMarkRange_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_GCMarkRange_) == 24 && NELUA_ALIGNOF(nelua_vector_GCMarkRange_) == 8, "Nelua and C disagree on type size or align");
static void nelua_vector_GCMarkRange__destroy(nelua_vector_GCMarkRange__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow_1(nelua_vector_GCMarkRange__ptr self);
static void nelua_assert_line_25(bool cond, nlstring msg);
static void nelua_vector_GCMarkRange__push(nelua_vector_GCMarkRange__ptr self, nelua_GCMarkRange v);
static nelua_GCMarkRange nelua_vector_GCMarkRange__pop(nelua_vector_GCMarkRange__ptr self);
static void nelua_assert_line_26(bool cond, nlstring msg);
typedef nelua_vector_pure_line_* nelua_vector_pure_line__ptr;
static NELUA_NOINLINE void nelua_vectorT_grow_2(nelua_vector_pure_line__ptr self);
static void nelua_assert_line_27(bool cond, nlstring msg);
static void nelua_vector_pure_line__push(nelua_vector_pure_line__ptr self, parser_pure_line v);
static NELUA_INLINE parser_pure_line_ptr nelua_vector_pure_line____atindex(nelua_vector_pure_line__ptr self, uintptr_t pos);
static void nelua_assert_line_28(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_vector_pure_line____len(nelua_vector_pure_line__ptr self);
typedef struct nelua_vector_macro_ nelua_vector_macro_;
typedef nelua_vector_macro_* nelua_vector_macro__ptr;
struct nelua_vector_macro_ {
  nelua_span_macro_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_macro_) == 24 && NELUA_ALIGNOF(nelua_vector_macro_) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE void nelua_vectorT_grow_3(nelua_vector_macro__ptr self);
static void nelua_assert_line_29(bool cond, nlstring msg);
static void nelua_vector_macro__push(nelua_vector_macro__ptr self, macro_macro v);
static NELUA_INLINE macro_macro_ptr nelua_vector_macro____atindex(nelua_vector_macro__ptr self, uintptr_t pos);
static void nelua_assert_line_30(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_vector_macro____len(nelua_vector_macro__ptr self);
typedef struct nelua_vector_boolean_ nelua_vector_boolean_;
typedef nelua_vector_boolean_* nelua_vector_boolean__ptr;
struct nelua_vector_boolean_ {
  nelua_span_boolean_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_boolean_) == 24 && NELUA_ALIGNOF(nelua_vector_boolean_) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE void nelua_vectorT_grow_4(nelua_vector_boolean__ptr self);
static void nelua_assert_line_31(bool cond, nlstring msg);
static void nelua_vector_boolean__push(nelua_vector_boolean__ptr self, bool v);
static NELUA_INLINE nlboolean_ptr nelua_vector_boolean____atindex(nelua_vector_boolean__ptr self, uintptr_t pos);
static void nelua_assert_line_32(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_vector_boolean____len(nelua_vector_boolean__ptr self);
typedef nelua_vector_uint8_* nelua_vector_uint8__ptr;
static NELUA_NOINLINE void nelua_vectorT_grow_5(nelua_vector_uint8__ptr self);
static void nelua_assert_line_33(bool cond, nlstring msg);
static void nelua_vector_uint8__push(nelua_vector_uint8__ptr self, uint8_t v);
static NELUA_INLINE nluint8_ptr nelua_vector_uint8____atindex(nelua_vector_uint8__ptr self, uintptr_t pos);
static void nelua_assert_line_34(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_vector_uint8____len(nelua_vector_uint8__ptr self);
typedef struct nelua_vector_block_ nelua_vector_block_;
struct nelua_vector_block_ {
  nelua_span_block_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_block_) == 24 && NELUA_ALIGNOF(nelua_vector_block_) == 8, "Nelua and C disagree on type size or align");
typedef nelua_vector_block_* nelua_vector_block__ptr;
static nelua_vector_block_ nelua_vector_block__copy(nelua_vector_block__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow_6(nelua_vector_block__ptr self);
static void nelua_assert_line_35(bool cond, nlstring msg);
static void nelua_vector_block__push(nelua_vector_block__ptr self, assembler_block v);
static NELUA_INLINE assembler_block_ptr nelua_vector_block____atindex(nelua_vector_block__ptr self, uintptr_t pos);
static void nelua_assert_line_36(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_vector_block____len(nelua_vector_block__ptr self);
static NELUA_INLINE bool nelua_hasflag(uintptr_t flags, uintptr_t flag);
static NELUA_INLINE uintptr_t nelua_align_forward(uintptr_t addr, uintptr_t align);
static NELUA_INLINE bool nelua_GCItem_ismarked(nelua_GCItem_ptr self);
typedef struct nelua_GC nelua_GC;
struct nelua_GC {
  bool running;
  bool collecting;
  uintptr_t pause;
  uintptr_t membytes;
  uintptr_t lastmembytes;
  uintptr_t minaddr;
  uintptr_t maxaddr;
  uintptr_t stacktop;
  uintptr_t stackbottom;
  nelua_vector_pointer_ frees;
  nelua_vector_GCMarkRange_ markranges;
  nelua_hashmap_pointer__GCItem_ items;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GC) == 160 && NELUA_ALIGNOF(nelua_GC) == 8, "Nelua and C disagree on type size or align");
static nelua_GC nelua_gc;
typedef nelua_GC* nelua_GC_ptr;
static void nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize);
static void nelua_assert_line_37(bool cond, nlstring msg);
static NELUA_NOINLINE NELUA_GC_NO_SANITIZE void nelua_GC_markptrs(nelua_GC_ptr self, uintptr_t low, uintptr_t high);
static NELUA_NOINLINE void nelua_GC_markptr(nelua_GC_ptr self, void* ptr);
static NELUA_NOINLINE void nelua_GC_unmarkall(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_markroot(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_markstack(nelua_GC_ptr self);
typedef union nelua_RegsBuf nelua_RegsBuf;
union nelua_RegsBuf {
  jmp_buf regs;
  void* firstreg;
};
static void nelua_GC_mark(nelua_GC_ptr self);
typedef void (*function_mNaReKd45y8iCxwL)(nelua_GC_ptr);
static NELUA_NOINLINE void nelua_GC_sweep(nelua_GC_ptr self);
static void nelua_assert_line_38(bool cond, nlstring msg);
static void nelua_assert_line_39(bool cond, nlstring msg);
static NELUA_NOINLINE void nelua_GC_collect(nelua_GC_ptr self);
static void nelua_GC_registerroots(nelua_GC_ptr self);
typedef void (*function_EBMPDqQww4btCKeA)(void*, void*);
static bool nelua_GC_step(nelua_GC_ptr self);
static void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_EBMPDqQww4btCKeA finalizer, void* userdata);
static void nelua_assert_line_40(bool cond, nlstring msg);
static void nelua_GC_reregister(nelua_GC_ptr self, void* oldptr, void* newptr, uintptr_t newsize);
static void nelua_assert_line_41(bool cond, nlstring msg);
static void nelua_assert_line_42(bool cond, nlstring msg);
static void nelua_assert_line_43(bool cond, nlstring msg);
static void nelua_GC_restart(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_init(nelua_GC_ptr self, void* stack);
static NELUA_NOINLINE void nelua_GC_destroy(nelua_GC_ptr self);
typedef char** nlcstring_ptr;
int main(int argc, nlcstring_ptr argv);
typedef int (*function_2gRr3LajZwa4Rc1Tg)(int, nlcstring_ptr);
static nelua_GCAllocator nelua_gc_allocator;
typedef nelua_GCAllocator* nelua_GCAllocator_ptr;
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_2(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_3(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc0_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc0_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr);
static NELUA_NOINLINE void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* ptr, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_uint8_ nelua_GCAllocator_spanalloc_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_pure_line_ nelua_GCAllocator_spanalloc_3(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_macro_ nelua_GCAllocator_spanalloc_4(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_boolean_ nelua_GCAllocator_spanalloc_5(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_block_ nelua_GCAllocator_spanalloc_6(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_usize_ nelua_GCAllocator_spanalloc_7(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_uint8_ nelua_GCAllocator_spanalloc0_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_hashmapnode_string__uint64__ nelua_GCAllocator_spanalloc0_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
typedef struct nelua_FStream nelua_FStream;
typedef nelua_FStream* nelua_FStream_ptr;
typedef FILE* FILE_ptr;
typedef int (*function_52sCYyeorDXncPqWM)(FILE_ptr);
struct nelua_FStream {
  FILE_ptr fp;
  function_52sCYyeorDXncPqWM closef;
};
NELUA_STATIC_ASSERT(sizeof(nelua_FStream) == 16 && NELUA_ALIGNOF(nelua_FStream) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE nelua_FStream_ptr nelua_GCAllocator_new_2(nelua_GCAllocator_ptr self, nelua_FStream what, nlniltype size, nlniltype flags);
static void nelua_assert_line_44(bool cond, nlstring msg);
static void* nelua_GCAllocator_xalloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags);
static void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_block_ nelua_GCAllocator_xspanalloc_6(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static void nelua_GCAllocator_spandealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s);
static nelua_span_uint8_ nelua_GCAllocator_spanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_pure_line_ nelua_GCAllocator_spanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_pure_line_ s, uintptr_t size);
static nelua_span_macro_ nelua_GCAllocator_spanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_macro_ s, uintptr_t size);
static nelua_span_boolean_ nelua_GCAllocator_spanrealloc_5(nelua_GCAllocator_ptr self, nelua_span_boolean_ s, uintptr_t size);
static nelua_span_block_ nelua_GCAllocator_spanrealloc_6(nelua_GCAllocator_ptr self, nelua_span_block_ s, uintptr_t size);
static nelua_span_usize_ nelua_GCAllocator_spanrealloc_7(nelua_GCAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GCAllocator_xspanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_pure_line_ nelua_GCAllocator_xspanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_pure_line_ s, uintptr_t size);
static nelua_span_macro_ nelua_GCAllocator_xspanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_macro_ s, uintptr_t size);
static nelua_span_boolean_ nelua_GCAllocator_xspanrealloc_5(nelua_GCAllocator_ptr self, nelua_span_boolean_ s, uintptr_t size);
static nelua_span_block_ nelua_GCAllocator_xspanrealloc_6(nelua_GCAllocator_ptr self, nelua_span_block_ s, uintptr_t size);
static nelua_span_usize_ nelua_GCAllocator_xspanrealloc_7(nelua_GCAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GCAllocator_spanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_hashmapnode_string__uint64__ nelua_GCAllocator_spanrealloc0_2(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__uint64__ s, uintptr_t size);
static nelua_span_hashmapnode_string__uint64__ nelua_GCAllocator_xspanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__uint64__ s, uintptr_t size);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_stringbuilderT) == 24 && NELUA_ALIGNOF(nelua_stringbuilderT) == 8, "Nelua and C disagree on type size or align");
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize);
static nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_assert_line_45(bool cond, nlstring msg);
static bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n);
typedef struct nlmulret_nlboolean_nlusize {
  bool r1;
  uintptr_t r2;
} nlmulret_nlboolean_nlusize;
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_write_1(nelua_stringbuilderT_ptr self, nlstring __arg1);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_write_2(nelua_stringbuilderT_ptr self, int64_t __arg1);
typedef struct nlmulret_nlboolean_nlisize {
  bool r1;
  intptr_t r2;
} nlmulret_nlboolean_nlisize;
static nlmulret_nlboolean_nlisize nelua_formatarg_4(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, uint64_t arg1);
static NELUA_INLINE size_t nelua_assert_narrow_nlisize_nlcsize(intptr_t x);
static void nelua_assert_line_46(bool cond, nlstring msg);
static void nelua_assert_line_47(bool cond, nlstring msg);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_5(nelua_stringbuilderT_ptr self, nlstring fmt, uint64_t __arg1);
static void nelua_assert_line_48(bool cond, nlstring msg);
static nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self);
typedef struct nelua_sequence_string__1 nelua_sequence_string__1;
typedef nelua_sequence_string__1* nelua_sequence_string__1_ptr;
struct nelua_sequence_string__1 {
  nelua_sequenceimpl_string__1_ptr impl;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_sequence_string__1) == 8 && NELUA_ALIGNOF(nelua_sequence_string__1) == 8, "Nelua and C disagree on type size or align");
static void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self);
static void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n);
static NELUA_NOINLINE void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self);
static void nelua_assert_line_49(bool cond, nlstring msg);
static NELUA_INLINE nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t pos);
static void nelua_assert_line_50(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_sequence_string__1___len(nelua_sequence_string__1_ptr self);
static nlstring nelua_nlstring_create(uintptr_t size);
static void nelua_assert_line_51(bool cond, nlstring msg);
static void nelua_nlstring_destroy(nlstring_ptr self);
static nlstring nelua_nlstring_copy(nlstring s);
static uint8_t nelua_nlstring_byte_1(nlstring s, nlniltype i);
static void nelua_assert_line_52(bool cond, nlstring msg);
static nlstring nelua_nlstring_sub_1(nlstring s, intptr_t i, intptr_t j);
static nlstring nelua_nlstring_upper(nlstring s);
static nlstring nelua_nlstring_char_1(uint8_t __arg1);
static nlstring nelua_nlstring_format_5(nlstring fmt, uint64_t __arg1);
static NELUA_INLINE intptr_t nelua_nlstring___len(nlstring a);
static nlstring nelua_nlstring___concat_2(nlstring a, nlstring b);
static bool nelua_nlstring___eq(nlstring a, nlstring b);
static nlstring nelua_tostring_1(parser_pure_line x);
static nlstring nelua_tostring_2(int64_t x);
static nlstring nelua_tostring_9(uint64_t x);
static int64_t nelua_tointeger_1(nlstring x, int64_t base);
static NELUA_INLINE uint64_t nelua_assert_narrow_nlint64_nluint64(int64_t x);
static void nelua_assert_line_53(bool cond, nlstring msg);
static int64_t nelua_tointeger_2(double x, nlniltype base);
typedef struct nelua_filestream nelua_filestream;
struct nelua_filestream {
  nelua_FStream_ptr fs;
};
NELUA_STATIC_ASSERT(sizeof(nelua_filestream) == 8 && NELUA_ALIGNOF(nelua_filestream) == 8, "Nelua and C disagree on type size or align");
typedef int (*function_2tAa5Unug5rRi1sug)(FILE_ptr);
static nelua_filestream nelua_filestream__fromfp(FILE_ptr fp, function_2tAa5Unug5rRi1sug closef);
typedef nelua_filestream* nelua_filestream_ptr;
static NELUA_INLINE FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self);
typedef struct nlmulret_nlstring_nlint64 {
  nlstring r1;
  int64_t r2;
} nlmulret_nlstring_nlint64;
static nlmulret_nlstring_nlint64 nelua_geterrno(void);
static NELUA_INLINE nlstring nelua_cstring2string(const char* s);
typedef struct nlmulret_nelua_filestream_nlstring_nlint64 {
  nelua_filestream r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nelua_filestream_nlstring_nlint64;
static nlmulret_nelua_filestream_nlstring_nlint64 nelua_filestream_open_1(nlstring filename, nlstring mode);
static bool nelua_checkmode(nlstring mode_1);
static void nelua_assert_line_54(bool cond, nlstring msg);
static NELUA_INLINE char* nelua_assert_string2cstring(nlstring s);
typedef struct nlmulret_nlboolean_nlstring_nlint64 {
  bool r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlboolean_nlstring_nlint64;
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_close(nelua_filestream_ptr self);
typedef struct nlmulret_nlboolean_nlstring {
  bool r1;
  nlstring r2;
} nlmulret_nlboolean_nlstring;
static nlmulret_nlboolean_nlstring nelua_readline(nelua_stringbuilderT_ptr sb, FILE_ptr fp, bool chop);
static NELUA_INLINE bool nelua_eq_nlcint_nluint8(int a, uint8_t b);
static nlmulret_nlboolean_nlstring nelua_readall(nelua_stringbuilderT_ptr sb, FILE_ptr fp);
typedef struct nlmulret_nlstring_nlstring_nlint64 {
  nlstring r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlstring_nlstring_nlint64;
static nlmulret_nlstring_nlstring_nlint64 nelua_filestream_read_1(nelua_filestream_ptr self, nlstring fmt);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_2(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2, nlstring __arg3);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_3(nelua_filestream_ptr self, nlstring __arg1, assembler_block_types __arg2, nlstring __arg3);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_4(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_5(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2, nlstring __arg3, nlstring __arg4, nlstring __arg5);
static nelua_FStream nelua_stderrfs;
static nelua_filestream nelua_io_stderr;
static nelua_FStream nelua_stdoutfs;
static nelua_filestream nelua_io_stdout;
static nlmulret_nelua_filestream_nlstring_nlint64 nelua_io_open_1(nlstring filename, nlstring mode);
static nltype nelua_require_io(nlniltype modname);
static nltype nelua_require_io_cached(nlniltype modname);
static NELUA_NORETURN void nelua_os_exit_1(int64_t code);
static NELUA_INLINE int nelua_assert_narrow_nlint64_nlcint(int64_t x);
static nelua_sequence_string__1 nelua_arg;
static int nelua_argc;
typedef char** nlcstring_arr0_ptr;
static nlcstring_arr0_ptr nelua_argv;
static nelua_sequence_string__1 nelua_require_arg(nlniltype modname);
typedef struct nlmulret_nlint64_nlboolean {
  int64_t r1;
  bool r2;
} nlmulret_nlint64_nlboolean;
static nlmulret_nlint64_nlboolean utils_check_decimal(nlstring str);
static nlmulret_nlint64_nlboolean utils_check_hex(nlstring str);
static nlmulret_nlint64_nlboolean utils_check_integer(nlstring str);
static void nelua_require_utils(nlniltype modname);
static void nelua_require_utils_cached(nlniltype modname);
static int64_t parser_pure_line___len(parser_pure_line_ptr self);
static nlstring parser_pure_line___index(parser_pure_line_ptr self, int64_t i);
static NELUA_INLINE int64_t nelua_assert_bounds_nlint64(int64_t index, uintptr_t len);
static nlstring parser_pure_line___tostring(parser_pure_line_ptr self);
typedef parser_pure_file* parser_pure_file_ptr;
static intptr_t parser_pure_file___len(parser_pure_file_ptr self);
static parser_pure_line parser_pure_file___index(parser_pure_file_ptr self, int64_t i);
static NELUA_INLINE uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x);
static void parser_pure_file_push_line(parser_pure_file_ptr self, parser_pure_line line);
static void parser_pure_file_push_file(parser_pure_file_ptr self, parser_pure_file file);
static parser_pure_file parser_pure_file_sub(parser_pure_file_ptr self, int64_t start, int64_t stop);
static parser_pure_file parser_pure_file_copy(parser_pure_file_ptr self);
static parser_pure_file parser_pure_file_word_swap(parser_pure_file_ptr self, int64_t i, int64_t j, nlstring new_str);
static bool parser_is_whitespace(nlstring s);
static parser_pure_line parser_purify_line(nlstring s);
static parser_pure_file parser_purify_string(nlstring s);
static parser_pure_file parser_purify_file(nelua_filestream file);
static nelua_vector_macro_ macro_list;
static bool macro_check_arg_formed_OK(macro_macro m);
static bool macro_check_arg_use_OK(macro_macro m);
static NELUA_INLINE uintptr_t nelua_assert_narrow_nlisize_nlusize(intptr_t x);
static bool macro_register_macro(nlstring name, int64_t number_of_args, parser_pure_file content);
static int64_t macro_EXP_MACRO_ERR_OK = 0;
static int64_t macro_EXP_MACRO_ERR_NOT_FOUND = 1;
static int64_t macro_EXP_MACRO_ERR_INVALID_ARG = 2;
static int64_t macro_EXP_MACRO_ERR_MALFORMED_NUMBER = 3;
typedef struct nlmulret_parser_pure_file_nlint64 {
  parser_pure_file r1;
  int64_t r2;
} nlmulret_parser_pure_file_nlint64;
static nlmulret_parser_pure_file_nlint64 macro_expend_macro(parser_pure_line line);
static bool macro_is_macro(nlstring name);
static void nelua_require_macro(nlniltype modname);
typedef struct assemble_line_instruction assemble_line_instruction;
typedef int64_t assemble_line_args_choice;
struct assemble_line_instruction {
  nlstring mnemonic;
  assemble_line_args_choice argument;
  uint8_t opcode;
};
NELUA_STATIC_ASSERT(sizeof(assemble_line_instruction) == 32 && NELUA_ALIGNOF(assemble_line_instruction) == 8, "Nelua and C disagree on type size or align");
typedef struct NELUA_MAYALIAS assemble_line_instruction_arr28 {assemble_line_instruction v[28];} assemble_line_instruction_arr28;
typedef union NELUA_MAYALIAS assemble_line_instruction_arr28_cast {assemble_line_instruction_arr28 a; assemble_line_instruction p[28];} assemble_line_instruction_arr28_cast;
NELUA_STATIC_ASSERT(sizeof(assemble_line_instruction_arr28) == 896 && NELUA_ALIGNOF(assemble_line_instruction_arr28) == 8, "Nelua and C disagree on type size or align");
static assemble_line_instruction_arr28 assemble_line_instruction_list = {.v = {{{(uint8_t*)"SET", 3}, 3, 0x1U}, {{(uint8_t*)"READ", 4}, 1, 0x2U}, {{(uint8_t*)"CPY", 3}, 1, 0x3U}, {{(uint8_t*)"ADD", 3}, 1, 0x4U}, {{(uint8_t*)"SUB", 3}, 1, 0x5U}, {{(uint8_t*)"AND", 3}, 1, 0x6U}, {{(uint8_t*)"OR", 2}, 1, 0x7U}, {{(uint8_t*)"XOR", 3}, 1, 0x8U}, {{(uint8_t*)"NOT", 3}, 1, 0x9U}, {{(uint8_t*)"LSL", 3}, 1, 0xaU}, {{(uint8_t*)"LSR", 3}, 1, 0xbU}, {{(uint8_t*)"EQ", 2}, 1, 0xcU}, {{(uint8_t*)"LES", 3}, 1, 0xdU}, {{(uint8_t*)"STR", 3}, 1, 0xeU}, {{(uint8_t*)"LOAD", 4}, 1, 0xfU}, {{(uint8_t*)"SLP", 3}, 0, 0x0U}, {{(uint8_t*)"CMPNOT", 6}, 0, 0x1U}, {{(uint8_t*)"RETINT", 6}, 0, 0x2U}, {{(uint8_t*)"TBM", 3}, 0, 0x3U}, {{(uint8_t*)"CC2", 3}, 0, 0x8U}, {{(uint8_t*)"JIF", 3}, 0, 0x9U}, {{(uint8_t*)"POP", 3}, 0, 0xaU}, {{(uint8_t*)"PUSH", 4}, 0, 0xbU}, {{(uint8_t*)"CALL", 4}, 0, 0xcU}, {{(uint8_t*)"RET", 3}, 0, 0xdU}, {{(uint8_t*)"QUIT", 4}, 0, 0xeU}, {{(uint8_t*)"DEBUG", 5}, 0, 0xfU}, {{(uint8_t*)"SETINT", 6}, 2, 0x1U}}};
static bool assemble_line_is_mnemonic_valid(nlstring mnemonic);
static NELUA_INLINE intptr_t nelua_assert_bounds_nlisize(intptr_t index, uintptr_t len);
static assemble_line_instruction assemble_line_get_inst(nlstring mnemonic);
static bool assemble_line_is_reg_valid(nlstring reg);
static uint8_t assemble_line_reg_to_num(nlstring reg);
static bool assemble_line_is_line_valid(parser_pure_line line);
static uint8_t assemble_line_asm_line(parser_pure_line line);
static NELUA_INLINE uint8_t nelua_assert_narrow_nlint64_nluint8(int64_t x);
typedef struct nlmulret_nluint8_nlint64_nlstring {
  uint8_t r1;
  int64_t r2;
  nlstring r3;
} nlmulret_nluint8_nlint64_nlstring;
static nlmulret_nluint8_nlint64_nlstring assemble_line_assemble_line(parser_pure_line line);
static void nelua_require_assemble_line(nlniltype modname);
static assembler_block assembler_make_pure_file_block(assembler_pure_file_block in_block);
static nelua_vector_block_ assembler_delete_block(nelua_vector_block_ in_block, int64_t i);
static nelua_vector_block_ assembler_insert_block(nelua_vector_block_ in_block, int64_t i, assembler_block new_1);
static nelua_vector_block_ assembler_swap_block(nelua_vector_block_ in_block, int64_t i, assembler_block new_2);
static nelua_vector_block_ assembler_slice_pure_file_block(nelua_vector_block_ in_block, int64_t i, int64_t line_start, int64_t line_stop);
static nelua_vector_block_ assembler_insert_block_in_file(nelua_vector_block_ in_block, int64_t file_index, int64_t line, assembler_block new_block);
static void assembler_error_in_file(assembler_pure_file_block in_block, int64_t i);
static nlstring assembler_dir(nlstring filename);
typedef int64_t assembler_error_t;
typedef struct nlmulret_assembler_pure_file_block_assembler_error_t {
  assembler_pure_file_block r1;
  assembler_error_t r2;
} nlmulret_assembler_pure_file_block_assembler_error_t;
static nlmulret_assembler_pure_file_block_assembler_error_t assembler_open_file_block(nlstring filename);
typedef struct nlmulret_nelua_vector_block__assembler_error_t {
  nelua_vector_block_ r1;
  assembler_error_t r2;
} nlmulret_nelua_vector_block__assembler_error_t;
static nlmulret_nelua_vector_block__assembler_error_t assembler_first_step(nelua_vector_block_ in_block, int64_t addr_size);
typedef struct nlmulret_assembler_block_assembler_error_t {
  assembler_block r1;
  assembler_error_t r2;
} nlmulret_assembler_block_assembler_error_t;
static nlmulret_assembler_block_assembler_error_t assembler_gen_set8(int64_t num);
static NELUA_INLINE int64_t nelua_shr_nlint64(int64_t a, int64_t b);
static nlmulret_nelua_vector_block__assembler_error_t assembler_second_step(nelua_vector_block_ in_block, int64_t addr_size);
static nlmulret_nelua_vector_block__assembler_error_t assembler_third_step(nelua_vector_block_ in_block, int64_t addr_size);
static nlmulret_nelua_vector_block__assembler_error_t assembler_fourth_step(nelua_vector_block_ in_block, int64_t addr_size);
static NELUA_INLINE int64_t nelua_assert_imod_nlint64(int64_t a, int64_t b);
typedef struct nlmulret_nelua_hashmap_string__uint64__assembler_error_t {
  nelua_hashmap_string__uint64_ r1;
  assembler_error_t r2;
} nlmulret_nelua_hashmap_string__uint64__assembler_error_t;
static nlmulret_nelua_hashmap_string__uint64__assembler_error_t assembler_gen_label_map(nelua_vector_block_ in_block, int64_t addr_size, int64_t start_addr);
static void assembler_print_labels(nelua_hashmap_string__uint64_ map);
static void nelua_print_1(nlstring a1);
typedef struct nlmulret_nelua_vector_uint8__assembler_error_t {
  nelua_vector_uint8_ r1;
  assembler_error_t r2;
} nlmulret_nelua_vector_uint8__assembler_error_t;
static nlmulret_nelua_vector_uint8__assembler_error_t assembler_fifth_step(nelua_vector_block_ in_block, int64_t addr_size, int64_t start_addr, bool dump_label);
static NELUA_INLINE uint8_t nelua_assert_narrow_nluint64_nluint8(uint64_t x);
static NELUA_INLINE uint64_t nelua_shr_nluint64(uint64_t a, int64_t b);
typedef nlmulret_nelua_vector_block__assembler_error_t (*function_5gAM6Sd4txxQ1bfQd)(nelua_vector_block_, int64_t);
static nlmulret_nelua_vector_block__assembler_error_t assembler_run_step(nelua_vector_block_ in_block, function_5gAM6Sd4txxQ1bfQd step, int64_t addr_size);
static nlmulret_nelua_vector_uint8__assembler_error_t assembler_assemble(nlstring input_file, nlstring runtime_start, nlstring runtime_end, int64_t addr_size, int64_t start_addr, bool dump_label);
static void nelua_require_assembler(nlniltype modname);
typedef struct main_arg_flags main_arg_flags;
struct main_arg_flags {
  bool error;
  bool help;
  nlstring input;
  nlstring output;
  int64_t word_size;
  bool set_stack;
  int64_t stack_value;
  int64_t start_addr;
  bool ignore_start;
  bool no_prefix;
  bool label_dump;
};
NELUA_STATIC_ASSERT(sizeof(main_arg_flags) == 80 && NELUA_ALIGNOF(main_arg_flags) == 8, "Nelua and C disagree on type size or align");
static main_arg_flags main_parse_args(void);
static void main_check_flags_ok(main_arg_flags flags);
static char nelua_strlit_1[894] = "reflet-fpu-asm, an assembler for the Reflet FPU architecture.\n\nUsage:\n    reflet-fpu-asm <input-file> <options> -o <output-file>\n    reflet-fpu-asm -help\n\nOptions:\n* -no-prefix: does not put the 'ASRM' prefix at the beginning of the output file.\n* -word-size 8/16/32/64: indicate the size of registers in the target CPU.\n* -no-stack-init : does not initialize the stack pointer. When not used, the stack pointer is by default initialized to just after the program.\n* -set-stack-to xxx : set the stack pointer to the address given just after the flag. Incompatible with -no-stack-init. Defaults to 0 when not set.\n* -start-addr xxx : tell the linker that the code should start at the given address.\n* -ignore-start : if set, the program will not start at the \"start\" label but at the beginning of the input file.\n* -label-dump: if set, a dump of all labels will be printed just before linkage.\n";
static char nelua_strlit_2[81] = "Error, word-size is unspecified or invalid.\nValid values are 8, 16, 32, and 64.\n";
static nlstring main_make_start_runtime(main_arg_flags flags);
static char nelua_strlit_3[120] = "@define @set_wordsize_byte 0\n            set 7\n            cpy R12\n            set 1\n            add R12\n        @end\\n";
static char nelua_strlit_4[2413] = ";This macro is used to put the result of the 2 word macro in the WR.\n;It is used to form set+ or setlab\n@define set_to_constant 2\n    mov R11 SR\n    @set_default_sr\n    cpy SR\n    @set_wordsize_byte\n    cpy R12\n    @align_word\n    set 2\n    add R12\n    add PC\n    jmp\n    $1 $2\n    ;Jumped here\n    set 3\n    add R12 ;Contains the word size\n    cc2\n    add PC\n    load WR\n    mov SR R11\n@end\n\n@define set+ 1\n    set_to_constant @constant $1\n@end\n\n@define setlab 1\n    set_to_constant @labref $1\n@end\n\n@define goto 1\n    setlab $1\n    jmp\n@end\n\n@define callf 1\n    setlab $1\n    call\n@end\n\n@define jifl 1\n    setlab $1\n    jif\n@end\n\n@define setr 2\n    set+ $2\n    cpy $1\n@end\n\n@define mov. 2\n    read $2\n    cpy $1\n@end\n\n@define mov 2\n    cpy R12\n    mov. $1 $2\n    read R12\n@end\n\n@define pushr. 1\n    read $1\n    push\n@end\n\n@define pushr 1\n    cpy R12\n    pushr. $1\n    read R12\n@end\n\n@define popr. 1\n    pop\n    cpy $1\n@end\n\n@define popr 1\n    cpy R12\n    popr. $1\n    read R12\n@end\n\n@define addup. 1\n    add $1\n    cpy $1\n@end\n\n@define addup 1\n    cpy r12\n    addup. $1\n    read r12\n@end\n\n@define inc. 1\n    set 1\n    addup. $1\n    cpy $1\n@end\n\n@define inc 1\n    cpy r12\n    inc. $1\n    read r12\n@end\n\n@define inc_ws. 1\n    @set_wordsize_byte\n    addup. $1\n@end\n\n@define inc_ws 1\n    cpy r12\n    inc_ws. $1\n    read r12\n@end\n\n@define jmp 0\n    cpy PC\n@end\n\n@define label 1\n    @label $1\n@end\n\n@define rawbyte 1\n    @rawbytes $1\n@end\n\n@define set8 1\n    @set8 $1\n@end\n\n; Takes as first argument a value to mask the SR with and as second a register to load from\n@define @loadX 2\n    ; Preserve and set SR\n    mov. R12 SR\n    set $1\n    or SR\n    cpy SR\n    ; load\n    load $2\n    cpy R11\n    ; Restore SR\n    mov. SR R12\n    read R11\n@end\n\n; Same idea as @loadX but for str\n@define @strX 2\n    cpy R11\n    ; Preserve and set SR\n    mov. R12 SR\n    read SR\n    cpy R12\n    set $1\n    or SR\n    cpy SR\n    ; store\n    read R11\n    str $2\n    cpy R11\n    ; Restore SR\n    mov. SR R12\n    read R11\n@end\n\n; load/store 8 bits\n@define load8 1\n    @loadX 6 $1\n@end\n@define str8 1\n    @strX 6 $1\n@end\n\n; Load/store 16 bits\n@define load16 1\n    @loadX 4 $1\n@end\n@define str16 1\n    @strX 4 $1\n@end\n\n; Load/store 32 bits\n@define load32 1\n    @loadX 2 $1\n@end\n@define str32 1\n    @strX 2 $1\n@end\n\n; load/store 8 bits swifters\n@define load8. 1\n    tbm\n    load $1\n    tbm\n@end\n@define str8. 1\n    tbm\n    str $1\n    tbm\n@end\n";
static assembler_error_t main_reflet_fpu_asm_main(void);
static char nelua_strlit_5[96] = "@align 8 ; As of the, the assembler only supports up to 64 bits processors\n@label __code_end__\n";
static NELUA_INLINE int64_t nelua_assert_narrow_nlfloat64_nlint64(double x);
static assembler_error_t main_exit_code;
static int nelua_main(int argc, char** argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
bool nelua_span_uint8__empty(nelua_span_uint8_ self) {
  return (self.size == 0);
}
void nelua_write_stderr(const char* msg, uintptr_t len, bool flush) {
  if(len > 0 && msg) {
    fwrite(msg, 1, len, stderr);
  }
  if(flush) {
    fwrite("\n", 1, 1, stderr);
    fflush(stderr);
  }
}
void nelua_abort(void) {
  NELUA_UBSAN_UNREACHABLE();
  abort();
}
void nelua_assert_line_1(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i) {
  nelua_assert_line_1((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_2(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer_ self, uintptr_t i) {
  nelua_assert_line_2((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_3(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_GCMarkRange_ptr nelua_span_GCMarkRange____atindex(nelua_span_GCMarkRange_ self, uintptr_t i) {
  nelua_assert_line_3((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_4(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlusize_ptr nelua_span_usize____atindex(nelua_span_usize_ self, uintptr_t i) {
  nelua_assert_line_4((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_5(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem__ self, uintptr_t i) {
  nelua_assert_line_5((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_6(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlstring_ptr nelua_span_string____atindex(nelua_span_string_ self, uintptr_t i) {
  nelua_assert_line_6((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_7(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
parser_pure_line_ptr nelua_span_pure_line____atindex(nelua_span_pure_line_ self, uintptr_t i) {
  nelua_assert_line_7((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_8(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
macro_macro_ptr nelua_span_macro____atindex(nelua_span_macro_ self, uintptr_t i) {
  nelua_assert_line_8((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_9(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlboolean_ptr nelua_span_boolean____atindex(nelua_span_boolean_ self, uintptr_t i) {
  nelua_assert_line_9((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_10(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
assembler_block_ptr nelua_span_block____atindex(nelua_span_block_ self, uintptr_t i) {
  nelua_assert_line_10((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_11(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/span.nelua\033[1m:90:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 79, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_string__uint64__ptr nelua_span_hashmapnode_string__uint64_____atindex(nelua_span_hashmapnode_string__uint64__ self, uintptr_t i) {
  nelua_assert_line_11((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring nelua_pairs_1(nelua_hashmap_string__uint64__ptr a) {
  nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring _ret_1 = nelua_hashmap_string__uint64____pairs(a);
  return (nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a) {
  nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer _ret_1 = nelua_hashmap_pointer__GCItem____mpairs(a);
  return (nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
void nelua_assert_line_12(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:27:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(dest and src, 'invalid pointer')\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 89, true);
    nelua_abort();
  }
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  nelua_assert_line_12(((dest != NULL) && (src != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memcpy(dest, src, (size_t)n);
}
void nelua_assert_line_13(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:60:9: \033[31m\033[1mruntime error: \033[0m\033[1m", 80, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(dest, 'invalid pointer')\n        \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 73, true);
    nelua_abort();
  }
}
void nelua_memory_zero(void* dest, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  nelua_assert_line_13((dest != NULL), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memset(dest, 0, (size_t)n);
}
void nelua_assert_line_14(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:89:11: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(a and b, 'invalid pointer')\n          \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 79, true);
    nelua_abort();
  }
}
bool nelua_memory_equals(void* a, void* b, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return true;
  }
  nelua_assert_line_14(((a != NULL) && (b != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  return (memcmp(a, b, (size_t)n) == 0);
}
void nelua_assert_line_15(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:102:9: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(src, 'invalid pointer')\n        \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 71, true);
    nelua_abort();
  }
}
void* nelua_memory_scan(void* src, uint8_t x, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return (void*)NULL;
  }
  nelua_assert_line_15((src != NULL), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  return memchr(src, (int)x, (size_t)n);
}
void nelua_assert_line_16(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/memory.nelua\033[1m:153:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(dest.size >= src.size, 'span sizes must be equal')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 116, true);
    nelua_abort();
  }
}
void nelua_memory_spancopy_8(nelua_span_block_ dest, nelua_span_block_ src) {
  nelua_assert_line_16((dest.size >= src.size), ((nlstring){(uint8_t*)"span sizes must be equal", 24}));
  if(NELUA_LIKELY((src.size > 0))) {
    memcpy((void*)dest.data, (void*)src.data, (size_t)(src.size * 80));
  }
}
void nelua_panic_cstring(const char* s) {
  if(s) {
    nelua_write_stderr(s, strlen(s), true);
  }
  nelua_abort();
}
void* nelua_assert_deref(void* p) {
  if(NELUA_UNLIKELY(p == NULL)) {
    nelua_panic_cstring("attempt to dereference a null pointer");
  }
  return p;
}
void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i += 1) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(dest, i))) = x;
  }
}
uint8_t nelua_strchar_1_toupper(uint8_t c) {
  return ((((uint32_t)c - 97U) < 26) ? (c & 0x5f) : c);
}
bool nelua_strchar_1_isdigit(uint8_t c) {
  return (((uint32_t)c - 48U) < 10);
}
bool nelua_strchar_1_isspace(uint8_t c) {
  return ((c == 32U) || (((uint32_t)c - 9U) < 5));
}
uint8_t nelua_strchar_1_getbasedigit(uint8_t c) {
  uint8_t d = (c - 48U);
  if((d < 10)) {
    return d;
  }
  d = (c - 97U);
  if((d < 26)) {
    return (d + 10);
  }
  d = (c - 65U);
  if((d < 26)) {
    return (d + 10);
  }
  return 255U;
}
nlmulret_nlboolean_nlint64 nelua_strconv_1_str2int(nlstring s, uint64_t base) {
  if((s.size == 0)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  uintptr_t pos = 0U;
  while(((pos < s.size) && nelua_strchar_1_isspace(s.data[pos]))) {
    pos = (pos + 1);
  }
  if((pos >= s.size)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  bool neg = false;
  if((s.data[pos] == 45U)) {
    pos = (pos + 1);
    neg = true;
  } else if((s.data[pos] == 43U)) {
    pos = (pos + 1);
  }
  if((base == 0)) {
    base = 10U;
    if(((s.data[pos] == 48U) && ((pos + 1) < s.size))) {
      uint8_t bc = s.data[(pos + 1)];
      if(((bc == 98U) || (bc == 66U))) {
        base = 2U;
        pos = (pos + 2);
      } else if(((bc == 120U) || (bc == 88U))) {
        base = 16U;
        pos = (pos + 2);
      }
    }
  }
  if((!((base >= 2) && (base <= 36)))) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  uint64_t n = 0U;
  while((pos < s.size)) {
    uint64_t x = (uint64_t)nelua_strchar_1_getbasedigit(s.data[pos]);
    if((x >= base)) {
      break;
    }
    n = ((n * base) + x);
    pos = (pos + 1);
  }
  while(((pos < s.size) && nelua_strchar_1_isspace(s.data[pos]))) {
    pos = (pos + 1);
  }
  if((pos != s.size)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  if(neg) {
    n = (-n);
  }
  return (nlmulret_nlboolean_nlint64){true, (int64_t)n};
}
uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
nlstring nelua_strconv_1_int2str_1(nluint8_arr48_ptr buf, int64_t x, nlniltype base) {
  uintptr_t pos = 47U;
  buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 0U;
  pos = (pos - 1);
  bool neg = (x < 0);
  if((x == 0)) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 48U;
    pos = (pos - 1);
  } else {
    while((x != 0)) {
      int64_t quot = (x / 10);
      int64_t rema = (x - (quot * 10));
      if((rema < 0)) {
        rema = (-rema);
      }
      x = quot;
      buf->v[nelua_assert_bounds_nlusize(pos, 48)] = (uint8_t)(rema + 48);
      pos = (pos - 1);
    }
  }
  if(neg) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 45U;
    pos = (pos - 1);
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&buf->v[nelua_assert_bounds_nlusize((pos + 1), 48)])), .size = ((48 - pos) - 2)};
}
nlstring nelua_strconv_1_int2str_2(nluint8_arr48_ptr buf, intptr_t x, nlniltype base) {
  uintptr_t pos = 47U;
  buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 0U;
  pos = (pos - 1);
  bool neg = (x < 0);
  if((x == 0)) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 48U;
    pos = (pos - 1);
  } else {
    while((x != 0)) {
      intptr_t quot = (x / 10);
      intptr_t rema = (x - (quot * 10));
      if((rema < 0)) {
        rema = (-rema);
      }
      x = quot;
      buf->v[nelua_assert_bounds_nlusize(pos, 48)] = (uint8_t)(rema + 48);
      pos = (pos - 1);
    }
  }
  if(neg) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 45U;
    pos = (pos - 1);
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&buf->v[nelua_assert_bounds_nlusize((pos + 1), 48)])), .size = ((48 - pos) - 2)};
}
nlstring nelua_strconv_1_int2str_4(nluint8_arr48_ptr buf, assembler_block_types x, nlniltype base) {
  uintptr_t pos = 47U;
  buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 0U;
  pos = (pos - 1);
  bool neg = (x < 0);
  if((x == 0)) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 48U;
    pos = (pos - 1);
  } else {
    while((x != 0)) {
      assembler_block_types quot = (x / 10);
      assembler_block_types rema = (x - (quot * 10));
      if((rema < 0)) {
        rema = (-rema);
      }
      x = quot;
      buf->v[nelua_assert_bounds_nlusize(pos, 48)] = (uint8_t)(rema + 48);
      pos = (pos - 1);
    }
  }
  if(neg) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 45U;
    pos = (pos - 1);
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&buf->v[nelua_assert_bounds_nlusize((pos + 1), 48)])), .size = ((48 - pos) - 2)};
}
nlstring nelua_strconv_1_int2str_6(nluint8_arr48_ptr buf, uintptr_t x, nlniltype base) {
  uintptr_t pos = 47U;
  buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 0U;
  pos = (pos - 1);
  bool neg = (x < 0);
  if((x == 0)) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 48U;
    pos = (pos - 1);
  } else {
    while((x != 0)) {
      uintptr_t quot = (x / 10U);
      uintptr_t rema = (x - (quot * 10U));
      x = quot;
      buf->v[nelua_assert_bounds_nlusize(pos, 48)] = (uint8_t)(rema + 48);
      pos = (pos - 1);
    }
  }
  if(neg) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 45U;
    pos = (pos - 1);
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&buf->v[nelua_assert_bounds_nlusize((pos + 1), 48)])), .size = ((48 - pos) - 2)};
}
void nelua_assert_line_17(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:29:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 88, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(p < L_FMTFLAGS.size + 1, \"invalid format (repeated flags)\")\n           \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 129, true);
    nelua_abort();
  }
}
void nelua_assert_line_18(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:37:10: \033[31m\033[1mruntime error: \033[0m\033[1m", 88, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(not strchar.isdigit(strfmt[p]), \"invalid format (width or precision too long)\")\n         \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 156, true);
    nelua_abort();
  }
}
uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form) {
  uintptr_t p = 0U;
  while(((strfmt[p] != 0) && (nelua_memory_scan((void*)((nlstring){(uint8_t*)"-+ #0", 5}).data, strfmt[p], 5U) != (void*)NULL))) {
    p = (p + 1);
  }
  nelua_assert_line_17((p < (((nlstring){(uint8_t*)"-+ #0", 5}).size + 1)), ((nlstring){(uint8_t*)"invalid format (repeated flags)", 31}));
  if(nelua_strchar_1_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if(nelua_strchar_1_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if((strfmt[p] == 46U)) {
    p = (p + 1);
    if(nelua_strchar_1_isdigit(strfmt[p])) {
      p = (p + 1);
    }
    if(nelua_strchar_1_isdigit(strfmt[p])) {
      p = (p + 1);
    }
  }
  nelua_assert_line_18((!nelua_strchar_1_isdigit(strfmt[p])), ((nlstring){(uint8_t*)"invalid format (width or precision too long)", 44}));
  form->v[0] = 37U;
  nelua_memory_copy((void*)(&form->v[1]), (void*)(&strfmt[0]), (p + 1));
  form->v[nelua_assert_bounds_nlusize((p + 2), 32)] = 0U;
  return p;
}
size_t nelua_assert_bounds_nlcsize(size_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
void nelua_addlenmod(nluint8_arr32_ptr form, char* lenmod, size_t lenmodsize) {
  size_t l = (size_t)((intptr_t)strlen((char*)(&form->v[0])));
  uint8_t spec = form->v[nelua_assert_bounds_nlcsize((l - 1), 32)];
  nelua_memory_copy((void*)(&form->v[nelua_assert_bounds_nlcsize((l - 1), 32)]), (void*)lenmod, (uintptr_t)lenmodsize);
  form->v[nelua_assert_bounds_nlcsize(((l + lenmodsize) - 1), 32)] = spec;
  form->v[nelua_assert_bounds_nlcsize((l + lenmodsize), 32)] = 0U;
}
void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc_2(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void* nelua_GeneralAllocator_alloc0_2(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(NELUA_UNLIKELY((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((newsize == 0))) {
    if(NELUA_LIKELY((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_panic_string(nlstring s) {
  if(s.size > 0) {
    nelua_write_stderr((const char*)s.data, s.size, true);
  }
  nelua_abort();
}
void* nelua_GeneralAllocator_xalloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  void* p = nelua_GeneralAllocator_alloc0_1(self, size, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlpointer_arr0_ptr data = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_alloc_2(self, (size * 8), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlpointer_arr0_ptr)NULL)))) {
      return (nelua_span_pointer_){.data = data, .size = size};
    }
  }
  return (nelua_span_pointer_){0};
}
nelua_span_GCMarkRange_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    uintptr_t flags_1 = 262144U;
    nelua_GCMarkRange_arr0_ptr data = ((nelua_GCMarkRange_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 16), flags_1));
    if(NELUA_LIKELY((data != ((nelua_GCMarkRange_arr0_ptr)NULL)))) {
      return (nelua_span_GCMarkRange_){.data = data, .size = size};
    }
  }
  return (nelua_span_GCMarkRange_){0};
}
nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    uintptr_t flags_2 = 262144U;
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 8), flags_2));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){.data = data, .size = size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_string_ nelua_GeneralAllocator_spanalloc_4(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlstring_arr0_ptr data = ((nlstring_arr0_ptr)nelua_GeneralAllocator_alloc_2(self, (size * 16), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlstring_arr0_ptr)NULL)))) {
      return (nelua_span_string_){.data = data, .size = size};
    }
  }
  return (nelua_span_string_){0};
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_pointer__GCItem__arr0_ptr data = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_alloc0_1(self, (size * 64), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_pointer__GCItem__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_pointer__GCItem__){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCMarkRange_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlpointer_arr0_ptr p = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlpointer_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_GCMarkRange_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCMarkRange_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_2(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_GCMarkRange_arr0_ptr p = ((nelua_GCMarkRange_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_GCMarkRange_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_3(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_string_ nelua_GeneralAllocator_spanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_4(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlstring_arr0_ptr p = ((nlstring_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlstring_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_GCMarkRange_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCMarkRange_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_3(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_4(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_pointer__GCItem__arr0_ptr p = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 64), (s.size * 64)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_1(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_sequenceimpl_string__1_ptr ptr = ((nelua_sequenceimpl_string__1_ptr)nelua_GeneralAllocator_xalloc0_1(self, 24U, NELUA_NIL));
  return ptr;
}
uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step) {
  seed = (seed ^ len);
  while((len >= step)) {
    seed = (seed ^ (((seed << 5) + (seed >> 2)) + data[(len - 1)]));
    len = (len - step);
  }
  return seed;
}
uintptr_t nelua_hash_long(nelua_span_uint8_ data) {
  return nelua_lhash(data.data, data.size, 0x9e3779b9ULL, ((data.size >> 5) + 1));
}
uintptr_t nelua_hash_hash_1(void* v) {
  return ((uintptr_t)v >> 3);
}
uintptr_t nelua_hash_hash_2(nlstring v) {
  return nelua_hash_long((nelua_span_uint8_){.data = v.data, .size = v.size});
}
uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n) {
  return (h % ((n - 1) | 1));
}
uintptr_t nelua_roundpow2(uintptr_t n) {
  if(((n & (n - 1)) == 0)) {
    return n;
  }
  n = (n | (n >> 1));
  n = (n | (n >> 2));
  n = (n | (n >> 4));
  n = (n | (n >> 8));
  n = (n | (n >> 16));
  n = (n | (n >> 32));
  n = (n + 1);
  return n;
}
void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self) {
  nelua_GeneralAllocator_spandealloc_3((&self->allocator), self->buckets);
  nelua_GeneralAllocator_spandealloc_4((&self->allocator), self->nodes);
  self->buckets = (nelua_span_usize_){0};
  self->nodes = (nelua_span_hashmapnode_pointer__GCItem__){0};
  self->size = 0U;
  self->free_index = 0U;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t h = nelua_hash_hash_1(key);
  uintptr_t bucket_index = nelua_hashmod(h, self->buckets.size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))));
    bool eq = (key == node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_19(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:212:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))) = (nelua_hashmapnode_pointer__GCItem_){0};
    }
    nelua_assert_line_19((j == self->size));
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_20(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:268:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_pointer__GCItem__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->free_index;
    nelua_assert_line_20((node_index_1 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index_1))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_1;
    } else {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = node_index_1;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_pointer__GCItem__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_1;
  }
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, nelua_hashmap_pointer__GCItem___at(self, key)))).value);
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t node_index = nelua_hashmap_pointer__GCItem___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))).value);
  }
  return ((nelua_GCItem_ptr)NULL);
}
nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if(NELUA_UNLIKELY((node_index == 0xffffffffffffffffULL))) {
    return (nelua_GCItem){0};
  }
  nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))));
  nelua_GCItem value = node->value;
  if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.next = self->free_index};
  self->free_index = node_index;
  return value;
}
uintptr_t nelua_hashmap_pointer__GCItem__bucketcount(nelua_hashmap_pointer__GCItem__ptr self) {
  return self->buckets.size;
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_hashmap_iteratorT__next_node(nelua_hashmap_iteratorT_ptr self, void* key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->container->nodes, self->index))));
    if(node->filled) {
      return node;
    }
    self->index = (self->index + 1);
  }
  return ((nelua_hashmapnode_pointer__GCItem__ptr)NULL);
}
nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key) {
  nelua_hashmapnode_pointer__GCItem__ptr node = nelua_hashmap_iteratorT__next_node(self, key);
  if((!(node != NULL))) {
    return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){false, NULL, ((nelua_GCItem_ptr)NULL)};
  }
  return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){true, node->key, (&node->value)};
}
nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self) {
  return (nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer){nelua_hashmap_iteratorT_mnext, (nelua_hashmap_iteratorT){.container = self, .index = 0xffffffffffffffffULL}, NULL};
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__uint64___find(nelua_hashmap_string__uint64__ptr self, nlstring key) {
  uintptr_t h = nelua_hash_hash_2(key);
  uintptr_t bucket_index = nelua_hashmod(h, self->buckets.size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_string__uint64__ptr node = (&(*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, node_index))));
    bool eq = nelua_nlstring___eq(key, node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_21(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:212:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  182, true);
    nelua_abort();
  }
}
void nelua_hashmap_string__uint64__rehash(nelua_hashmap_string__uint64__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, i))) = (nelua_hashmapnode_string__uint64_){0};
    }
    nelua_assert_line_21((j == self->size));
  }
  self->nodes = nelua_GCAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GCAllocator_xspanrealloc_7((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_string__uint64__ptr node = (&(*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__uint64___find(self, (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_22(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:268:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 83, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_string__uint64___at(nelua_hashmap_string__uint64__ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_string__uint64__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__uint64___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_2 = self->free_index;
    nelua_assert_line_22((node_index_2 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_string__uint64__ptr node = (&(*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, node_index_2))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(node)) = (nelua_hashmapnode_string__uint64_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_2;
    } else {
      (*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, prev_node_index))).next = node_index_2;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_string__uint64__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_2;
  }
}
nluint64_ptr nelua_hashmap_string__uint64____atindex(nelua_hashmap_string__uint64__ptr self, nlstring key) {
  return (&(*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, nelua_hashmap_string__uint64___at(self, key)))).value);
}
nluint64_ptr nelua_hashmap_string__uint64__peek(nelua_hashmap_string__uint64__ptr self, nlstring key) {
  uintptr_t node_index = nelua_hashmap_string__uint64___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->nodes, node_index))).value);
  }
  return (nluint64_ptr)NULL;
}
nelua_hashmapnode_string__uint64__ptr nelua_hashmap_iteratorT_1__next_node(nelua_hashmap_iteratorT_1_ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_string__uint64__ptr node = (&(*(nelua_hashmapnode_string__uint64_*)nelua_assert_deref(nelua_span_hashmapnode_string__uint64_____atindex(self->container->nodes, self->index))));
    if(node->filled) {
      return node;
    }
    self->index = (self->index + 1);
  }
  return ((nelua_hashmapnode_string__uint64__ptr)NULL);
}
nlmulret_nlboolean_nlstring_nluint64 nelua_hashmap_iteratorT_1_next(nelua_hashmap_iteratorT_1_ptr self, nlstring key) {
  nelua_hashmapnode_string__uint64__ptr node = nelua_hashmap_iteratorT_1__next_node(self, key);
  if((!(node != NULL))) {
    return (nlmulret_nlboolean_nlstring_nluint64){false, (nlstring){0}, 0U};
  }
  return (nlmulret_nlboolean_nlstring_nluint64){true, node->key, node->value};
}
nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring nelua_hashmap_string__uint64____pairs(nelua_hashmap_string__uint64__ptr self) {
  return (nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring){nelua_hashmap_iteratorT_1_next, (nelua_hashmap_iteratorT_1){.container = self, .index = 0xffffffffffffffffULL}, (nlstring){0}};
}
void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self) {
  self->size = 0U;
}
void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_pointer_){0};
  self->size = 0U;
}
void nelua_assert_line_23(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:120:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow(nelua_vector_pointer__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_23((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_1((&self->allocator), self->data, cap);
}
void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow(self);
  }
  (*(void**)nelua_assert_deref(nelua_span_pointer____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_24(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:219:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos) {
  nelua_assert_line_24((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(void**)nelua_assert_deref(nelua_span_pointer____atindex(self->data, pos))));
}
void nelua_vector_GCMarkRange__destroy(nelua_vector_GCMarkRange__ptr self) {
  nelua_GeneralAllocator_spandealloc_2((&self->allocator), self->data);
  self->data = (nelua_span_GCMarkRange_){0};
  self->size = 0U;
}
void nelua_assert_line_25(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:120:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow_1(nelua_vector_GCMarkRange__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_25((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->data, cap);
}
void nelua_vector_GCMarkRange__push(nelua_vector_GCMarkRange__ptr self, nelua_GCMarkRange v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow_1(self);
  }
  (*(nelua_GCMarkRange*)nelua_assert_deref(nelua_span_GCMarkRange____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_26(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:140:21: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(self.size > 0, 'attempt to pop an empty vector')\n                    \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 110, true);
    nelua_abort();
  }
}
nelua_GCMarkRange nelua_vector_GCMarkRange__pop(nelua_vector_GCMarkRange__ptr self) {
  nelua_assert_line_26((self->size > 0), ((nlstring){(uint8_t*)"attempt to pop an empty vector", 30}));
  self->size = (self->size - 1);
  return (*(nelua_GCMarkRange*)nelua_assert_deref(nelua_span_GCMarkRange____atindex(self->data, self->size)));
}
void nelua_assert_line_27(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:120:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow_2(nelua_vector_pure_line__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_27((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GCAllocator_xspanrealloc_3((&self->allocator), self->data, cap);
}
void nelua_vector_pure_line__push(nelua_vector_pure_line__ptr self, parser_pure_line v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow_2(self);
  }
  (*(parser_pure_line*)nelua_assert_deref(nelua_span_pure_line____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_28(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:219:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
parser_pure_line_ptr nelua_vector_pure_line____atindex(nelua_vector_pure_line__ptr self, uintptr_t pos) {
  nelua_assert_line_28((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(parser_pure_line*)nelua_assert_deref(nelua_span_pure_line____atindex(self->data, pos))));
}
intptr_t nelua_vector_pure_line____len(nelua_vector_pure_line__ptr self) {
  return (intptr_t)self->size;
}
void nelua_assert_line_29(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:120:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow_3(nelua_vector_macro__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_29((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GCAllocator_xspanrealloc_4((&self->allocator), self->data, cap);
}
void nelua_vector_macro__push(nelua_vector_macro__ptr self, macro_macro v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow_3(self);
  }
  (*(macro_macro*)nelua_assert_deref(nelua_span_macro____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_30(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:219:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
macro_macro_ptr nelua_vector_macro____atindex(nelua_vector_macro__ptr self, uintptr_t pos) {
  nelua_assert_line_30((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(macro_macro*)nelua_assert_deref(nelua_span_macro____atindex(self->data, pos))));
}
intptr_t nelua_vector_macro____len(nelua_vector_macro__ptr self) {
  return (intptr_t)self->size;
}
void nelua_assert_line_31(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:120:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow_4(nelua_vector_boolean__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_31((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GCAllocator_xspanrealloc_5((&self->allocator), self->data, cap);
}
void nelua_vector_boolean__push(nelua_vector_boolean__ptr self, bool v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow_4(self);
  }
  (*(bool*)nelua_assert_deref(nelua_span_boolean____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_32(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:219:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
nlboolean_ptr nelua_vector_boolean____atindex(nelua_vector_boolean__ptr self, uintptr_t pos) {
  nelua_assert_line_32((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(bool*)nelua_assert_deref(nelua_span_boolean____atindex(self->data, pos))));
}
intptr_t nelua_vector_boolean____len(nelua_vector_boolean__ptr self) {
  return (intptr_t)self->size;
}
void nelua_assert_line_33(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:120:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow_5(nelua_vector_uint8__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_33((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GCAllocator_xspanrealloc_1((&self->allocator), self->data, cap);
}
void nelua_vector_uint8__push(nelua_vector_uint8__ptr self, uint8_t v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow_5(self);
  }
  (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_34(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:219:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
nluint8_ptr nelua_vector_uint8____atindex(nelua_vector_uint8__ptr self, uintptr_t pos) {
  nelua_assert_line_34((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->data, pos))));
}
intptr_t nelua_vector_uint8____len(nelua_vector_uint8__ptr self) {
  return (intptr_t)self->size;
}
nelua_vector_block_ nelua_vector_block__copy(nelua_vector_block__ptr self) {
  nelua_vector_block_ clone = (nelua_vector_block_){0};
  if((self->size > 0)) {
    clone.data = nelua_GCAllocator_xspanalloc_6((&self->allocator), NELUA_NIL, self->data.size, NELUA_NIL);
    nelua_memory_spancopy_8(clone.data, self->data);
    clone.size = self->size;
  }
  self->allocator;
  return clone;
}
void nelua_assert_line_35(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:120:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow_6(nelua_vector_block__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_35((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GCAllocator_xspanrealloc_6((&self->allocator), self->data, cap);
}
void nelua_vector_block__push(nelua_vector_block__ptr self, assembler_block v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow_6(self);
  }
  (*(assembler_block*)nelua_assert_deref(nelua_span_block____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_36(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/vector.nelua\033[1m:219:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
assembler_block_ptr nelua_vector_block____atindex(nelua_vector_block__ptr self, uintptr_t pos) {
  nelua_assert_line_36((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(assembler_block*)nelua_assert_deref(nelua_span_block____atindex(self->data, pos))));
}
intptr_t nelua_vector_block____len(nelua_vector_block__ptr self) {
  return (intptr_t)self->size;
}
bool nelua_hasflag(uintptr_t flags, uintptr_t flag) {
  return ((flags & flag) != 0);
}
uintptr_t nelua_align_forward(uintptr_t addr, uintptr_t align) {
  return ((addr + (align - 1)) & (~(align - 1)));
}
bool nelua_GCItem_ismarked(nelua_GCItem_ptr self) {
  return nelua_hasflag(self->flags, 196608U);
}
void nelua_assert_line_37(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:127:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(item.ptr == ptr, 'invalid unregister pointer')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~\033[0m\n", 108, true);
    nelua_abort();
  }
}
void nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return;
  }
  nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
  nelua_assert_line_37((item.ptr == ptr), ((nlstring){(uint8_t*)"invalid unregister pointer", 26}));
  if((!nelua_hasflag(item.flags, 131072U))) {
    self->membytes = (self->membytes - item.size);
    for(uintptr_t i = 0U, _end = self->frees.size; i < _end; i += 1) {
      if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) == ptr)) {
        (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) = (void*)NULL;
        break;
      }
    }
  }
  if((finalize && (item.finalizer != NULL))) {
    item.finalizer(ptr, item.userdata);
  }
}
void nelua_GC_markptrs(nelua_GC_ptr self, uintptr_t low, uintptr_t high) {
  uintptr_t minaddr = self->minaddr;
  uintptr_t maxaddr = self->maxaddr;
  nelua_hashmap_pointer__GCItem__ptr items = (&self->items);
  nelua_vector_GCMarkRange__push((&self->markranges), (nelua_GCMarkRange){low, high});
  while((self->markranges.size > 0)) {
    nelua_GCMarkRange range = nelua_vector_GCMarkRange__pop((&self->markranges));
    for(uintptr_t memaddr = range.low, _end = range.high; memaddr < _end; memaddr += 8) {
      uintptr_t addr = (*(uintptr_t*)nelua_assert_deref((nlusize_ptr)memaddr));
      if(((addr >= minaddr) && (addr <= maxaddr))) {
        nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek(items, (void*)addr);
        if(((item != NULL) && (!nelua_GCItem_ismarked(item)))) {
          item->flags = (item->flags | 65536U);
          if((!nelua_hasflag(item->flags, 262144U))) {
            nelua_vector_GCMarkRange__push((&self->markranges), (nelua_GCMarkRange){addr, (addr + item->size)});
          }
        }
      }
    }
  }
}
void nelua_GC_markptr(nelua_GC_ptr self, void* ptr) {
  nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
  if(((item != NULL) && (!nelua_GCItem_ismarked(item)))) {
    item->flags = (item->flags | 65536U);
    if((!nelua_hasflag(item->flags, 262144U))) {
      uintptr_t addr = (uintptr_t)ptr;
      nelua_GC_markptrs(self, addr, (addr + item->size));
    }
  }
}
void nelua_GC_unmarkall(nelua_GC_ptr self) {
  {
    nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_31SABs3XansuHVrNg __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __fornextit);
      bool __forcont = _asgnret_2.r1;
      void* ptr = _asgnret_2.r2;
      nelua_GCItem_ptr item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = ptr;
      {
        item->flags = (item->flags & 18446744073709486079ULL);
      }
    }
  }
}
void nelua_GC_markroot(nelua_GC_ptr self) {
  {
    nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_31SABs3XansuHVrNg __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __fornextit);
      bool __forcont = _asgnret_2.r1;
      void* ptr = _asgnret_2.r2;
      nelua_GCItem_ptr item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = ptr;
      {
        if(nelua_hasflag(item->flags, 131072U)) {
          uintptr_t addr = (uintptr_t)ptr;
          nelua_GC_markptrs(self, addr, (addr + item->size));
        }
      }
    }
  }
}
void nelua_GC_markstack(nelua_GC_ptr self) {
  nelua_RegsBuf regsbuf;
  setjmp(regsbuf.regs);
#if defined(__GNUC__) || defined(__clang__)
  void* sp = __builtin_frame_address(0);
#endif
  uintptr_t low = ((self->stacktop == 0) ? (uintptr_t)(&regsbuf) : self->stacktop);
  uintptr_t high = self->stackbottom;
  if((high < low)) {
    uintptr_t _asgntmp_1 = high;
    uintptr_t _asgntmp_2 = low;
    low = _asgntmp_1;
    high = _asgntmp_2;
  }
  low = nelua_align_forward(low, 8U);
  nelua_GC_markptrs(self, low, high);
  nelua_GC_markptrs(self, (uintptr_t)(&regsbuf), ((uintptr_t)(&regsbuf) + (uintptr_t)sizeof(nelua_RegsBuf)));
#if defined(__GNUC__) || defined(__clang__)
  nelua_GC_markptr(self, sp);
#endif
}
void nelua_GC_mark(nelua_GC_ptr self) {
  nelua_GC_unmarkall(self);
  nelua_GC_markroot(self);
  if((self->stackbottom != 0)) {
    volatile function_mNaReKd45y8iCxwL markstack = nelua_GC_markstack;
    markstack(self);
  }
}
void nelua_assert_line_38(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:261:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        check(item ~= nilptr, 'gc item not found to finalize')\n                   \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 119, true);
    nelua_abort();
  }
}
void nelua_assert_line_39(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:277:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(item.ptr == ptr, 'gc item not found to deallocate')\n                     \033[1m\033[32m^\033[0m\033[35m~~~~~\033[0m\n", 119, true);
    nelua_abort();
  }
}
void nelua_GC_sweep(nelua_GC_ptr self) {
  bool finalize = false;
  {
    nlmulret_function_31SABs3XansuHVrNg_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_31SABs3XansuHVrNg __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __fornextit);
      bool __forcont = _asgnret_2.r1;
      void* ptr = _asgnret_2.r2;
      nelua_GCItem_ptr item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = ptr;
      {
        if((!nelua_GCItem_ismarked(item))) {
          nelua_vector_pointer__push((&self->frees), ptr);
          if(((!finalize) && (item->finalizer != NULL))) {
            finalize = true;
          }
        }
      }
    }
  }
  if(finalize) {
    uintptr_t i = 0U;
    while((i < self->frees.size)) {
      void* ptr = (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i)));
      if((ptr != NULL)) {
        nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
        nelua_assert_line_38((item != ((nelua_GCItem_ptr)NULL)), ((nlstring){(uint8_t*)"gc item not found to finalize", 29}));
        if(((item != NULL) && (item->finalizer != NULL))) {
          nelua_GCFinalizerCallback finalizer = item->finalizer;
          item->finalizer = (nelua_GCFinalizerCallback)NULL;
          finalizer(ptr, item->userdata);
        }
      }
      i = (i + 1);
    }
  }
  uintptr_t i = 0U;
  while((i < self->frees.size)) {
    void* ptr = (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i)));
    if((ptr != NULL)) {
      nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
      nelua_assert_line_39((item.ptr == ptr), ((nlstring){(uint8_t*)"gc item not found to deallocate", 31}));
      if((item.ptr != NULL)) {
        self->membytes = (self->membytes - item.size);
        if((!nelua_hasflag(item.flags, 1048576U))) {
          nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
        }
      }
    }
    i = (i + 1);
  }
  nelua_vector_pointer__clear((&self->frees));
}
void nelua_GC_collect(nelua_GC_ptr self) {
  if((self->collecting || (self->membytes == 0))) {
    return;
  }
  self->collecting = true;
  nelua_GC_mark(self);
  nelua_GC_sweep(self);
  self->lastmembytes = self->membytes;
  if(((self->items.size * 4) < nelua_hashmap_pointer__GCItem__bucketcount((&self->items)))) {
    nelua_hashmap_pointer__GCItem__rehash((&self->items), 0U);
  }
  self->collecting = false;
}
void nelua_GC_registerroots(nelua_GC_ptr self) {
  nelua_GC_register((&nelua_gc), (void*)(&nelua_arg), 8U, 131072U, (function_EBMPDqQww4btCKeA)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_io_stderr), 8U, 131072U, (function_EBMPDqQww4btCKeA)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_io_stdout), 8U, 131072U, (function_EBMPDqQww4btCKeA)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_stderrfs), 16U, 131072U, (function_EBMPDqQww4btCKeA)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_stdoutfs), 16U, 131072U, (function_EBMPDqQww4btCKeA)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&macro_list), 24U, 131072U, (function_EBMPDqQww4btCKeA)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&assemble_line_instruction_list), 896U, 131072U, (function_EBMPDqQww4btCKeA)NULL, (void*)NULL);
}
bool nelua_GC_step(nelua_GC_ptr self) {
  if(((!self->collecting) && ((self->membytes * 100) >= (self->lastmembytes * self->pause)))) {
    nelua_GC_collect(self);
    return true;
  }
  return false;
}
void nelua_assert_line_40(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:382:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(item.ptr == nilptr, 'cannot register pointer twice')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_EBMPDqQww4btCKeA finalizer, void* userdata) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return;
  }
  if(NELUA_UNLIKELY((size < 8))) {
    flags = (flags | 262144U);
  }
  nelua_GCItem_ptr item = (&(*(nelua_GCItem*)nelua_assert_deref(nelua_hashmap_pointer__GCItem____atindex((&self->items), ptr))));
  nelua_assert_line_40((item->ptr == (void*)NULL), ((nlstring){(uint8_t*)"cannot register pointer twice", 29}));
  (*(nelua_GCItem*)nelua_assert_deref(item)) = (nelua_GCItem){.flags = flags, .size = size, .ptr = ptr, .finalizer = finalizer, .userdata = userdata};
  if(NELUA_LIKELY((!nelua_hasflag(flags, 131072U)))) {
    uintptr_t addr = (uintptr_t)ptr;
    uintptr_t addrhigh = (addr + size);
    if((addrhigh > self->maxaddr)) {
      self->maxaddr = addrhigh;
    }
    if((addr < self->minaddr)) {
      self->minaddr = addr;
    }
    self->membytes = (self->membytes + size);
    if(self->running) {
      nelua_GC_step(self);
    }
  }
}
void nelua_assert_line_41(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:409:47: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(oldptr ~= nilptr and newptr ~= nilptr and newsize > 0, 'invalid reregister arguments')\n                                              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 184, true);
    nelua_abort();
  }
}
void nelua_assert_line_42(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:413:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(item ~= nilptr, 'invalid reregister pointer')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 110, true);
    nelua_abort();
  }
}
void nelua_assert_line_43(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:428:21: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(item.ptr ~= nilptr, 'invalid reregister pointer')\n                    \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 118, true);
    nelua_abort();
  }
}
void nelua_GC_reregister(nelua_GC_ptr self, void* oldptr, void* newptr, uintptr_t newsize) {
  nelua_assert_line_41((((oldptr != (void*)NULL) && (newptr != (void*)NULL)) && (newsize > 0)), ((nlstring){(uint8_t*)"invalid reregister arguments", 28}));
  uintptr_t oldsize = 0U;
  if((newptr == oldptr)) {
    nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), oldptr);
    nelua_assert_line_42((item != ((nelua_GCItem_ptr)NULL)), ((nlstring){(uint8_t*)"invalid reregister pointer", 26}));
    oldsize = item->size;
    item->size = newsize;
    if(NELUA_LIKELY((!nelua_hasflag(item->flags, 131072U)))) {
      if((newsize > oldsize)) {
        self->membytes = (self->membytes + (newsize - oldsize));
        if(self->running) {
          nelua_GC_step(self);
        }
      } else if((newsize < oldsize)) {
        self->membytes = (self->membytes - (oldsize - newsize));
      }
    }
  } else {
    nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), oldptr);
    nelua_assert_line_43((item.ptr != (void*)NULL), ((nlstring){(uint8_t*)"invalid reregister pointer", 26}));
    oldsize = item.size;
    if(NELUA_LIKELY((!nelua_hasflag(item.flags, 131072U)))) {
      self->membytes = (self->membytes - oldsize);
      for(uintptr_t i = 0U, _end = self->frees.size; i < _end; i += 1) {
        if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) == oldptr)) {
          (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) = newptr;
          break;
        }
      }
    }
    nelua_GC_register(self, newptr, newsize, item.flags, item.finalizer, item.userdata);
  }
}
void nelua_GC_restart(nelua_GC_ptr self) {
  self->running = true;
}
void nelua_GC_init(nelua_GC_ptr self, void* stack) {
  self->stackbottom = (uintptr_t)stack;
  self->minaddr = 0xffffffffffffffffULL;
  self->pause = 200U;
  nelua_GC_registerroots(self);
  nelua_GC_restart(self);
}
void nelua_GC_destroy(nelua_GC_ptr self) {
  nelua_GC_unmarkall(self);
  nelua_GC_sweep(self);
  nelua_hashmap_pointer__GCItem__destroy((&self->items));
  nelua_vector_pointer__destroy((&self->frees));
  nelua_vector_GCMarkRange__destroy((&self->markranges));
  (*(nelua_GC*)nelua_assert_deref(self)) = (nelua_GC){0};
}
int main(int argc, nlcstring_ptr argv) {
  nelua_GC_init((&nelua_gc), (void*)(&argc));
  volatile function_2gRr3LajZwa4Rc1Tg inner_main = nelua_main;
  int ret = inner_main(argc, argv);
  nelua_GC_destroy((&nelua_gc));
  return ret;
}
void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_3 = 0U;
  nelua_GCFinalizerCallback finalizer_1 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_1 = (void*)NULL;
  void* ptr = nelua_GeneralAllocator_alloc_1((&nelua_general_allocator), size, flags_3);
  nelua_GC_register((&nelua_gc), ptr, size, flags_3, finalizer_1, userdata_1);
  return ptr;
}
void* nelua_GCAllocator_alloc_2(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_4 = 0U;
  void* ptr = nelua_GeneralAllocator_alloc_1((&nelua_general_allocator), size, flags_4);
  nelua_GC_register((&nelua_gc), ptr, size, flags_4, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc_3(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  void* ptr = nelua_GeneralAllocator_alloc_1((&nelua_general_allocator), size, flags);
  nelua_GC_register((&nelua_gc), ptr, size, flags, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc0_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_5 = 0U;
  void* ptr = nelua_GeneralAllocator_alloc0_2((&nelua_general_allocator), size, flags_5);
  nelua_GC_register((&nelua_gc), ptr, size, flags_5, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc0_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  void* ptr = nelua_GeneralAllocator_alloc0_2((&nelua_general_allocator), size, flags);
  nelua_GC_register((&nelua_gc), ptr, size, flags, finalizer, userdata);
  return ptr;
}
void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr) {
  nelua_GC_unregister_1((&nelua_gc), ptr, true);
  nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
}
void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* ptr, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((ptr == (void*)NULL))) {
    return nelua_GCAllocator_alloc_1(self, newsize, NELUA_NIL, NELUA_NIL, NELUA_NIL);
  } else if(NELUA_UNLIKELY((newsize == 0))) {
    nelua_GCAllocator_dealloc(self, ptr);
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return ptr;
  } else {
    void* newptr = nelua_GeneralAllocator_realloc((&nelua_general_allocator), ptr, newsize, oldsize);
    if((newptr != NULL)) {
      nelua_GC_reregister((&nelua_gc), ptr, newptr, newsize);
    }
    return newptr;
  }
}
nelua_span_uint8_ nelua_GCAllocator_spanalloc_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_6 = 262144U;
  nelua_GCFinalizerCallback finalizer_2 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_2 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 1), flags_6, finalizer_2, userdata_2));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_pure_line_ nelua_GCAllocator_spanalloc_3(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_3 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_3 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    parser_pure_line_arr0_ptr data = ((parser_pure_line_arr0_ptr)nelua_GCAllocator_alloc_2(self, (size * 824), NELUA_NIL, finalizer_3, userdata_3));
    if(NELUA_LIKELY((data != ((parser_pure_line_arr0_ptr)NULL)))) {
      return (nelua_span_pure_line_){.data = data, .size = size};
    }
  }
  return (nelua_span_pure_line_){0};
}
nelua_span_macro_ nelua_GCAllocator_spanalloc_4(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_4 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_4 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    macro_macro_arr0_ptr data = ((macro_macro_arr0_ptr)nelua_GCAllocator_alloc_2(self, (size * 48), NELUA_NIL, finalizer_4, userdata_4));
    if(NELUA_LIKELY((data != ((macro_macro_arr0_ptr)NULL)))) {
      return (nelua_span_macro_){.data = data, .size = size};
    }
  }
  return (nelua_span_macro_){0};
}
nelua_span_boolean_ nelua_GCAllocator_spanalloc_5(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_7 = 262144U;
  nelua_GCFinalizerCallback finalizer_5 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_5 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nlboolean_arr0_ptr data = ((nlboolean_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 1), flags_7, finalizer_5, userdata_5));
    if(NELUA_LIKELY((data != ((nlboolean_arr0_ptr)NULL)))) {
      return (nelua_span_boolean_){.data = data, .size = size};
    }
  }
  return (nelua_span_boolean_){0};
}
nelua_span_block_ nelua_GCAllocator_spanalloc_6(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_6 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_6 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    assembler_block_arr0_ptr data = ((assembler_block_arr0_ptr)nelua_GCAllocator_alloc_2(self, (size * 80), NELUA_NIL, finalizer_6, userdata_6));
    if(NELUA_LIKELY((data != ((assembler_block_arr0_ptr)NULL)))) {
      return (nelua_span_block_){.data = data, .size = size};
    }
  }
  return (nelua_span_block_){0};
}
nelua_span_usize_ nelua_GCAllocator_spanalloc_7(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_8 = 262144U;
  nelua_GCFinalizerCallback finalizer_7 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_7 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 8), flags_8, finalizer_7, userdata_7));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){.data = data, .size = size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_uint8_ nelua_GCAllocator_spanalloc0_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_9 = 262144U;
  nelua_GCFinalizerCallback finalizer_8 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_8 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GCAllocator_alloc0_2(self, (size * 1), flags_9, finalizer_8, userdata_8));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_hashmapnode_string__uint64__ nelua_GCAllocator_spanalloc0_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  nelua_GCFinalizerCallback finalizer_9 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_9 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_string__uint64__arr0_ptr data = ((nelua_hashmapnode_string__uint64__arr0_ptr)nelua_GCAllocator_alloc0_1(self, (size * 40), NELUA_NIL, finalizer_9, userdata_9));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_string__uint64__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_string__uint64__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_string__uint64__){0};
}
void nelua_assert_line_44(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:762:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
nelua_FStream_ptr nelua_GCAllocator_new_2(nelua_GCAllocator_ptr self, nelua_FStream what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  nelua_FStream_ptr ptr;
  ptr = ((nelua_FStream_ptr)nelua_GCAllocator_alloc_2((&nelua_gc_allocator), 16U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_44((ptr != ((nelua_FStream_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  nelua_memory_copy((void*)ptr, (void*)(&what), 16U);
  return ptr;
}
void* nelua_GCAllocator_xalloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags) {
  void* p = nelua_GCAllocator_alloc_1(self, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GCAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_block_ nelua_GCAllocator_xspanalloc_6(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  nelua_span_block_ s = nelua_GCAllocator_spanalloc_6(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
void nelua_GCAllocator_spandealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc(self, (void*)s.data);
}
nelua_span_uint8_ nelua_GCAllocator_spanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_2(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_pure_line_ nelua_GCAllocator_spanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_pure_line_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_3(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  parser_pure_line_arr0_ptr p = ((parser_pure_line_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 824), (s.size * 824)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((parser_pure_line_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_macro_ nelua_GCAllocator_spanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_macro_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_4(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  macro_macro_arr0_ptr p = ((macro_macro_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 48), (s.size * 48)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((macro_macro_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_boolean_ nelua_GCAllocator_spanrealloc_5(nelua_GCAllocator_ptr self, nelua_span_boolean_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_5(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nlboolean_arr0_ptr p = ((nlboolean_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlboolean_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_block_ nelua_GCAllocator_spanrealloc_6(nelua_GCAllocator_ptr self, nelua_span_block_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_6(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  assembler_block_arr0_ptr p = ((assembler_block_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 80), (s.size * 80)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((assembler_block_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GCAllocator_spanrealloc_7(nelua_GCAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_7(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_uint8_ nelua_GCAllocator_xspanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_pure_line_ nelua_GCAllocator_xspanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_pure_line_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_3(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_macro_ nelua_GCAllocator_xspanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_macro_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_4(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_boolean_ nelua_GCAllocator_xspanrealloc_5(nelua_GCAllocator_ptr self, nelua_span_boolean_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_5(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_block_ nelua_GCAllocator_xspanrealloc_6(nelua_GCAllocator_ptr self, nelua_span_block_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_6(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_usize_ nelua_GCAllocator_xspanrealloc_7(nelua_GCAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_7(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_uint8_ nelua_GCAllocator_spanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_1(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__uint64__ nelua_GCAllocator_spanrealloc0_2(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__uint64__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_2(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_string__uint64__arr0_ptr p = ((nelua_hashmapnode_string__uint64__arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 40), (s.size * 40)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_string__uint64__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__uint64__ nelua_GCAllocator_xspanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_hashmapnode_string__uint64__ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc0_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GCAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
}
bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize) {
  uintptr_t needed = (newsize + 1);
  uintptr_t cap = self->data.size;
  if((needed <= cap)) {
    return true;
  }
  if((cap == 0)) {
    cap = 16U;
  }
  while((cap < needed)) {
    cap = (cap * 2);
    if((cap <= 16U)) {
      return false;
    }
  }
  self->data = nelua_GCAllocator_spanrealloc0_1((&self->allocator), self->data, cap);
  if((self->data.size != cap)) {
    self->data = nelua_GCAllocator_spanrealloc0_1((&self->allocator), self->data, needed);
  }
  return (needed <= self->data.size);
}
nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, (self->size + n)))) {
    return (nelua_span_uint8_){0};
  }
  return (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&(*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->data, self->size))))), .size = ((self->data.size - self->size) - 1)};
}
void nelua_assert_line_45(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:150:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(newsize <= self.data.size, 'not enough space in string buffer')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 137, true);
    nelua_abort();
  }
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n) {
  uintptr_t newsize = (self->size + n);
  nelua_assert_line_45((newsize <= self->data.size), ((nlstring){(uint8_t*)"not enough space in string buffer", 33}));
  self->size = newsize;
}
bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n) {
  nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, 1U);
  if(NELUA_UNLIKELY(nelua_span_uint8__empty(p))) {
    return false;
  }
  p.data[0] = c;
  self->size = (self->size + 1);
  return true;
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_write_1(nelua_stringbuilderT_ptr self, nlstring __arg1) {
  uintptr_t written = 0U;
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, s.size);
      if(NELUA_UNLIKELY(nelua_span_uint8__empty(p))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      nelua_memory_copy((void*)p.data, (void*)s.data, s.size);
      written = (written + s.size);
      self->size = (self->size + s.size);
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_write_2(nelua_stringbuilderT_ptr self, int64_t __arg1) {
  uintptr_t written = 0U;
  {
    nluint8_arr48 buf;
    nlstring s = nelua_strconv_1_int2str_1((&buf), __arg1, NELUA_NIL);
    if((s.size > 0)) {
      nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, s.size);
      if(NELUA_UNLIKELY(nelua_span_uint8__empty(p))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      nelua_memory_copy((void*)p.data, (void*)s.data, s.size);
      written = (written + s.size);
      self->size = (self->size + s.size);
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
size_t nelua_assert_narrow_nlisize_nlcsize(intptr_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from isize to csize failed");
  }
  return (size_t)x;
}
void nelua_assert_line_46(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:353:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(false, 'invalid format for argument')\n           \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 93, true);
    nelua_abort();
  }
}
void nelua_assert_line_47(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:355:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(nb >= 0, 'unexpected number of bytes written in sprintf')\n              \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlisize nelua_formatarg_4(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, uint64_t arg1) {
  nelua_span_uint8_ buf = nelua_stringbuilderT_prepare(self, 128U);
  if((buf.size < 128U)) {
    return (nlmulret_nlboolean_nlisize){false, 0};
  }
  intptr_t nb = -1;
  if((c == 99U)) {
    int n = (int)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_9;
  }
  if(((c == 100U) || (c == 105U))) {
    char* lenmod = (char*)"lli";
    nelua_addlenmod(form, lenmod, nelua_assert_narrow_nlisize_nlcsize((((intptr_t)strlen(lenmod)) - 1)));
    long long n = (long long)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_9;
  }
  if(((((c == 111U) || (c == 117U)) || (c == 120U)) || (c == 88U))) {
    char* lenmod = (char*)"llu";
    nelua_addlenmod(form, lenmod, nelua_assert_narrow_nlisize_nlcsize((((intptr_t)strlen(lenmod)) - 1)));
    unsigned long long n = (unsigned long long)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_9;
  }
  if((((((((c == 97U) || (c == 65U)) || (c == 102U)) || (c == 101U)) || (c == 69U)) || (c == 103U)) || (c == 71U))) {
    double n = (double)arg1;
    nb = (intptr_t)snprintf((char*)buf.data, 128U, (char*)(&form->v[0]), n);
    goto nelua_next_9;
  }
  if((c == 115U)) {
    nlstring s = nelua_tostring_9(arg1);
    uintptr_t slen = (s.size + 1);
    if(((form->v[1] == c) && (form->v[2] == 0))) {
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      nelua_memory_copy((void*)buf.data, (void*)s.data, s.size);
      nb = (intptr_t)s.size;
    } else {
      if((slen < 128U)) {
        slen = 128U;
      }
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      char* cs = (char*)s.data;
      if((s.size == 0)) {
        cs = (char*)"";
      }
      nb = (intptr_t)snprintf((char*)buf.data, (size_t)buf.size, (char*)(&form->v[0]), cs);
    }
    nelua_nlstring_destroy((&s));
    goto nelua_next_9;
  }
  nelua_assert_line_46(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_9:;
  nelua_assert_line_47((nb >= 0), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlisize){true, nb};
}
void nelua_assert_line_48(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:393:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 89, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n          assert(false, 'bad format argument (no value)')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 108, true);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_5(nelua_stringbuilderT_ptr self, nlstring fmt, uint64_t __arg1) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_4(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_8;
        }
        nelua_assert_line_48(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_8:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    nelua_stringbuilderT_destroy(self);
    return (nlstring){0};
  }
  uintptr_t size = self->size;
  nelua_span_uint8_ data = nelua_GCAllocator_xspanrealloc_1((&self->allocator), self->data, (size + 1));
  (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(data, size))) = 0U;
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
  return (nlstring){.data = data.data, .size = size};
}
void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GeneralAllocator_new_1((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n) {
  nelua_sequence_string__1__init(self);
  uintptr_t cap = (n + 1);
  uintptr_t curcap = self->impl->data.size;
  if((curcap >= cap)) {
    return;
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_4((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, 0U))) = (nlstring){0};
  }
}
void nelua_assert_line_49(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:147:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > curcap, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
    nelua_assert_line_49((cap > curcap), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_4((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, 0U))) = (nlstring){0};
  }
}
void nelua_assert_line_50(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:255:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 84, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(pos == self.impl.size + 1, 'position out of bounds')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t pos) {
  nelua_sequence_string__1__init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_line_50((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_1(self);
    }
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, pos))) = (nlstring){0};
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_1(self);
  }
  return (&(*(nlstring*)nelua_assert_deref(nelua_span_string____atindex(self->impl->data, pos))));
}
intptr_t nelua_sequence_string__1___len(nelua_sequence_string__1_ptr self) {
  if(NELUA_UNLIKELY((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void nelua_assert_line_51(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:35:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(size > 0, 'attempt to create an empty string')\n             \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
nlstring nelua_nlstring_create(uintptr_t size) {
  nelua_assert_line_51((size > 0), ((nlstring){(uint8_t*)"attempt to create an empty string", 33}));
  nlstring s = (nlstring){.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc_1((&nelua_gc_allocator), (size + 1), NELUA_NIL)), .size = size};
  s.data[size] = 0U;
  return s;
}
void nelua_nlstring_destroy(nlstring_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc((&nelua_gc_allocator), (void*)self->data);
  self->data = ((nluint8_arr0_ptr)NULL);
  self->size = 0U;
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = (nlstring){0};
  if(NELUA_UNLIKELY((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc_1((&nelua_gc_allocator), (s.size + 1), NELUA_NIL));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  clone.data[s.size] = 0U;
  clone.size = s.size;
  return clone;
}
void nelua_assert_line_52(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:82:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 81, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(i >= 1 and (@usize)(i) <= s.size, 'index out of range')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 132, true);
    nelua_abort();
  }
}
uint8_t nelua_nlstring_byte_1(nlstring s, nlniltype i) {
  intptr_t i_1 = 1;
  if(NELUA_UNLIKELY((s.size == 0))) {
    return 0U;
  }
  if(NELUA_UNLIKELY((i_1 < 0))) {
    i_1 = (intptr_t)((int64_t)(s.size + i_1) + 1);
  }
  nelua_assert_line_52(((i_1 >= 1) && ((uintptr_t)i_1 <= s.size)), ((nlstring){(uint8_t*)"index out of range", 18}));
  return s.data[(i_1 - 1)];
}
nlstring nelua_nlstring_sub_1(nlstring s, intptr_t i, intptr_t j) {
  intptr_t size = (intptr_t)s.size;
  if(NELUA_UNLIKELY((size == 0))) {
    return (nlstring){0};
  }
  if(NELUA_UNLIKELY((i < 0))) {
    i = ((size + i) + 1);
  }
  if(NELUA_UNLIKELY((i <= 0))) {
    i = 1;
  }
  if(NELUA_UNLIKELY((j < 0))) {
    j = ((size + j) + 1);
  }
  if(NELUA_UNLIKELY((j > size))) {
    j = size;
  }
  if(NELUA_UNLIKELY(((i == 1) && (j == size)))) {
    return nelua_nlstring_copy(s);
  }
  if(NELUA_UNLIKELY((i > j))) {
    return (nlstring){0};
  }
  uintptr_t subsize = (uintptr_t)((j - i) + 1);
  if(NELUA_UNLIKELY((subsize == 0))) {
    return (nlstring){0};
  }
  nlstring ret = nelua_nlstring_create(subsize);
  nelua_memory_copy((void*)(&ret.data[0]), (void*)(&s.data[(i - 1)]), subsize);
  return ret;
}
nlstring nelua_nlstring_upper(nlstring s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return s;
  }
  nlstring ret = nelua_nlstring_create(s.size);
  for(uintptr_t i = 0U, _end = s.size; i < _end; i += 1) {
    ret.data[i] = nelua_strchar_1_toupper(s.data[i]);
  }
  return ret;
}
nlstring nelua_nlstring_char_1(uint8_t __arg1) {
  nlstring s = nelua_nlstring_create(1U);
  s.data[0] = __arg1;
  return s;
}
nlstring nelua_nlstring_format_5(nlstring fmt, uint64_t __arg1) {
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  nelua_stringbuilderT_writef_5((&sb), fmt, __arg1);
  return nelua_stringbuilderT_promote((&sb));
}
intptr_t nelua_nlstring___len(nlstring a) {
  return (intptr_t)a.size;
}
nlstring nelua_nlstring___concat_2(nlstring a, nlstring b) {
  if((a.size == 0)) {
    return nelua_nlstring_copy(b);
  } else if((b.size == 0)) {
    return nelua_nlstring_copy(a);
  }
  nlstring s = nelua_nlstring_create((a.size + b.size));
  nelua_memory_copy((void*)s.data, (void*)a.data, a.size);
  nelua_memory_copy((void*)(&s.data[a.size]), (void*)b.data, b.size);
  return s;
}
bool nelua_nlstring___eq(nlstring a, nlstring b) {
  return ((a.size == b.size) && (((a.data == b.data) || (a.size == 0)) || nelua_memory_equals((void*)a.data, (void*)b.data, a.size)));
}
nlstring nelua_tostring_1(parser_pure_line x) {
  return parser_pure_line___tostring((&x));
}
nlstring nelua_tostring_2(int64_t x) {
  nluint8_arr48 buf;
  nlstring s = nelua_strconv_1_int2str_2((&buf), (intptr_t)x, NELUA_NIL);
  return nelua_nlstring_copy(s);
}
nlstring nelua_tostring_9(uint64_t x) {
  nluint8_arr48 buf;
  nlstring s = nelua_strconv_1_int2str_6((&buf), (uintptr_t)x, NELUA_NIL);
  return nelua_nlstring_copy(s);
}
uint64_t nelua_assert_narrow_nlint64_nluint64(int64_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from int64 to uint64 failed");
  }
  return (uint64_t)x;
}
void nelua_assert_line_53(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/string.nelua\033[1m:996:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 82, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ok, 'malformed integer')\n           \033[1m\033[32m^\033[0m\033[35m~\033[0m\n", 77, true);
    nelua_abort();
  }
}
int64_t nelua_tointeger_1(nlstring x, int64_t base) {
  nlmulret_nlboolean_nlint64 _asgnret_1 = nelua_strconv_1_str2int(x, nelua_assert_narrow_nlint64_nluint64(base));
  bool ok = _asgnret_1.r1;
  int64_t i = _asgnret_1.r2;
  nelua_assert_line_53(ok, ((nlstring){(uint8_t*)"malformed integer", 17}));
  return i;
}
int64_t nelua_tointeger_2(double x, nlniltype base) {
  return (int64_t)x;
}
nelua_filestream nelua_filestream__fromfp(FILE_ptr fp, function_2tAa5Unug5rRi1sug closef) {
  return (nelua_filestream){.fs = nelua_GCAllocator_new_2((&nelua_gc_allocator), (nelua_FStream){.fp = fp, .closef = closef}, NELUA_NIL, NELUA_NIL)};
}
FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self) {
  if((!(self->fs != NULL))) {
    return ((FILE_ptr)NULL);
  }
  return self->fs->fp;
}
nlstring nelua_cstring2string(const char* s) {
  if(s == NULL) {
    return (nlstring){0};
  }
  uintptr_t size = strlen(s);
  if(size == 0) {
    return (nlstring){0};
  }
  return (nlstring){(uint8_t*)s, size};
}
nlmulret_nlstring_nlint64 nelua_geterrno(void) {
  return (nlmulret_nlstring_nlint64){nelua_cstring2string(strerror(errno)), (int64_t)errno};
}
bool nelua_checkmode(nlstring mode_1) {
  if((nelua_nlstring___len(mode_1) == 0)) {
    return false;
  }
  if((nelua_memory_scan((void*)(char*)"rwa", mode_1.data[0], 3U) == (void*)NULL)) {
    return false;
  }
  uintptr_t pos = 1U;
  if((mode_1.data[pos] == 43U)) {
    pos = (pos + 1);
  }
  if((mode_1.data[pos] == 98U)) {
    pos = (pos + 1);
  }
  return (mode_1.data[pos] == 0);
}
void nelua_assert_line_54(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/usr/local/lib/nelua/lib/filestream.nelua\033[1m:93:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 85, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(checkmode(mode), 'invalid mode')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~\033[0m\n", 94, true);
    nelua_abort();
  }
}
char* nelua_assert_string2cstring(nlstring s) {
  if(s.size == 0) {
    return (char*)"";
  }
  if(NELUA_UNLIKELY(s.data[s.size]) != 0) {
    nelua_panic_cstring("attempt to convert a non null terminated string to cstring");
  }
  return (char*)s.data;
}
nlmulret_nelua_filestream_nlstring_nlint64 nelua_filestream_open_1(nlstring filename, nlstring mode) {
  nelua_assert_line_54(nelua_checkmode(mode), ((nlstring){(uint8_t*)"invalid mode", 12}));
  FILE_ptr fp = fopen(nelua_assert_string2cstring(filename), nelua_assert_string2cstring(mode));
  if((!(fp != NULL))) {
    nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
    return (nlmulret_nelua_filestream_nlstring_nlint64){(nelua_filestream){0}, _ret_1.r1, _ret_1.r2};
  }
  nlmulret_nelua_filestream_nlstring_nlint64 _mulret_1;
  _mulret_1.r1 = nelua_filestream__fromfp(fp, fclose);
  _mulret_1.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_1.r3 = 0;
  return _mulret_1;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_close(nelua_filestream_ptr self) {
  nelua_FStream_ptr fs = self->fs;
  if(((!(fs != NULL)) || (!(fs->fp != NULL)))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  if((((fs->fp == stdout) || (fs->fp == stderr)) || (fs->fp == stdin))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"cannot close standard file", 26}), -1};
  }
  int res = 0;
  if((fs->closef != NULL)) {
    res = fs->closef(fs->fp);
  }
  self->fs->fp = ((FILE_ptr)NULL);
  self->fs->closef = (function_52sCYyeorDXncPqWM)NULL;
  if((res != 0)) {
    nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
    return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, (nlstring){0}, 0};
}
bool nelua_eq_nlcint_nluint8(int a, uint8_t b) {
  return (uint32_t)a == (uint32_t)b && a >= 0;
}
nlmulret_nlboolean_nlstring nelua_readline(nelua_stringbuilderT_ptr sb, FILE_ptr fp, bool chop) {
  int c = 0;
  {
    bool _repeat_stop;
    do {
      uint32_t nr = 0U;
      nelua_span_uint8_ buff = nelua_stringbuilderT_prepare(sb, 1024U);
      if(nelua_span_uint8__empty(buff)) {
        return (nlmulret_nlboolean_nlstring){false, ((nlstring){(uint8_t*)"out of buffer memory", 20})};
      }
      while((nr < 1024U)) {
        c = fgetc(fp);
        if(((c == EOF) || nelua_eq_nlcint_nluint8(c, 10U))) {
          break;
        }
        (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(buff, (uintptr_t)nr))) = (uint8_t)c;
        nr = (nr + 1);
      }
      nelua_stringbuilderT_commit(sb, (uintptr_t)nr);
      _repeat_stop = ((c == EOF) || nelua_eq_nlcint_nluint8(c, 10U));
    } while(!_repeat_stop);
  }
  if(((!chop) && nelua_eq_nlcint_nluint8(c, 10U))) {
    if((!nelua_stringbuilderT_writebyte_1(sb, (uint8_t)c, NELUA_NIL))) {
      return (nlmulret_nlboolean_nlstring){false, ((nlstring){(uint8_t*)"out of buffer memory", 20})};
    }
  }
  return (nlmulret_nlboolean_nlstring){(nelua_eq_nlcint_nluint8(c, 10U) || (sb->size > 0)), (nlstring){0}};
}
nlmulret_nlboolean_nlstring nelua_readall(nelua_stringbuilderT_ptr sb, FILE_ptr fp) {
  {
    bool _repeat_stop;
    do {
      nelua_span_uint8_ p = nelua_stringbuilderT_prepare(sb, 1024U);
      if(nelua_span_uint8__empty(p)) {
        return (nlmulret_nlboolean_nlstring){false, ((nlstring){(uint8_t*)"out of buffer memory", 20})};
      }
      size_t nr = fread((void*)p.data, 1U, 1024U, fp);
      nelua_stringbuilderT_commit(sb, (uintptr_t)nr);
      _repeat_stop = (nr < 1024U);
    } while(!_repeat_stop);
  }
  return (nlmulret_nlboolean_nlstring){true, (nlstring){0}};
}
nlmulret_nlstring_nlstring_nlint64 nelua_filestream_read_1(nelua_filestream_ptr self, nlstring fmt) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlstring_nlstring_nlint64){(nlstring){0}, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  bool success = false;
  nlstring errmsg = (nlstring){0};
  clearerr(fp);
  uint8_t c = fmt.data[0];
  if((c == 42U)) {
    c = fmt.data[1];
  }
  if((c == 108U)) {
    nlmulret_nlboolean_nlstring _asgnret_1 = nelua_readline((&sb), fp, true);
    success = _asgnret_1.r1;
    errmsg = _asgnret_1.r2;
  } else if((c == 76U)) {
    nlmulret_nlboolean_nlstring _asgnret_2 = nelua_readline((&sb), fp, false);
    success = _asgnret_2.r1;
    errmsg = _asgnret_2.r2;
  } else if((c == 97U)) {
    nlmulret_nlboolean_nlstring _asgnret_3 = nelua_readall((&sb), fp);
    success = _asgnret_3.r1;
    errmsg = _asgnret_3.r2;
  } else {
    nelua_panic_string(((nlstring){(uint8_t*)"invalid format", 14}));
  }
  int64_t status = 0;
  if((ferror(fp) != 0)) {
    success = false;
    nlmulret_nlstring_nlint64 _asgnret_4 = nelua_geterrno();
    errmsg = _asgnret_4.r1;
    status = _asgnret_4.r2;
  }
  nlstring s = (nlstring){0};
  if(success) {
    s = nelua_stringbuilderT_promote((&sb));
  } else {
    if((nelua_nlstring___len(errmsg) == 0)) {
      errmsg = ((nlstring){(uint8_t*)"eof", 3});
      status = (int64_t)EOF;
    } else if((status == 0)) {
      status = -1;
    }
    nelua_stringbuilderT_destroy((&sb));
  }
  return (nlmulret_nlstring_nlstring_nlint64){s, errmsg, status};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_2(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2, nlstring __arg3) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  {
    nlstring s = __arg2;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_2 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_2.r1, _ret_2.r2};
      }
    }
  }
  {
    nlstring s = __arg3;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_3 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_3.r1, _ret_3.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_3(nelua_filestream_ptr self, nlstring __arg1, assembler_block_types __arg2, nlstring __arg3) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  {
    nluint8_arr48 buf;
    nlstring s = nelua_strconv_1_int2str_4((&buf), __arg2, NELUA_NIL);
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_2 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_2.r1, _ret_2.r2};
      }
    }
  }
  {
    nlstring s = __arg3;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_3 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_3.r1, _ret_3.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_4(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  {
    nlstring s = __arg2;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_2 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_2.r1, _ret_2.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_5(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2, nlstring __arg3, nlstring __arg4, nlstring __arg5) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  {
    nlstring s = __arg2;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_2 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_2.r1, _ret_2.r2};
      }
    }
  }
  {
    nlstring s = __arg3;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_3 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_3.r1, _ret_3.r2};
      }
    }
  }
  {
    nlstring s = __arg4;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_4 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_4.r1, _ret_4.r2};
      }
    }
  }
  {
    nlstring s = __arg5;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_5 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_5.r1, _ret_5.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nelua_filestream_nlstring_nlint64 nelua_io_open_1(nlstring filename, nlstring mode) {
  nlmulret_nelua_filestream_nlstring_nlint64 _mulret_1;
  nlmulret_nelua_filestream_nlstring_nlint64 _ret_1 = nelua_filestream_open_1(filename, mode);
  _mulret_1.r1 = _ret_1.r1;
  _mulret_1.r2 = _ret_1.r2;
  _mulret_1.r3 = _ret_1.r3;
  return _mulret_1;
}
nltype nelua_require_io(nlniltype modname) {
  nelua_stderrfs = (nelua_FStream){.fp = stderr};
  nelua_io_stderr = (nelua_filestream){.fs = (&nelua_stderrfs)};
  nelua_stdoutfs = (nelua_FStream){.fp = stdout};
  nelua_io_stdout = (nelua_filestream){.fs = (&nelua_stdoutfs)};
  return NELUA_NIL;
}
nltype nelua_require_io_cached(nlniltype modname) {
  static bool loaded = false;
  static nltype cache;
  if(!loaded) {
    cache = nelua_require_io(NELUA_NIL);
    loaded = true;
  }
  return cache;
}
int nelua_assert_narrow_nlint64_nlcint(int64_t x) {
  if(NELUA_UNLIKELY(x > 0x7fffffff || x < (-2147483647-1))) {
    nelua_panic_cstring("narrow casting from int64 to cint failed");
  }
  return (int)x;
}
void nelua_os_exit_1(int64_t code) {
  exit(nelua_assert_narrow_nlint64_nlcint(code));
}
nelua_sequence_string__1 nelua_require_arg(nlniltype modname) {
  if((nelua_argc > 0)) {
    uintptr_t narg = (uintptr_t)(nelua_argc - 1);
    nelua_sequence_string__1_reserve((&nelua_arg), narg);
    for(uintptr_t i = 0U, _end = narg; i <= _end; i += 1) {
      (*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), i))) = nelua_cstring2string(nelua_argv[i]);
    }
  }
  return nelua_arg;
}
nlmulret_nlint64_nlboolean utils_check_decimal(nlstring str) {
  int64_t ok_digits = 0;
  for(intptr_t i = 1, _end = nelua_nlstring___len(str); i <= _end; i += 1) {
    nlstring ch = nelua_nlstring_sub_1(str, i, i);
    for(intptr_t j = 1, _end = nelua_nlstring___len(((nlstring){(uint8_t*)"0123456789", 10})); j <= _end; j += 1) {
      nlstring cmp = nelua_nlstring_sub_1(((nlstring){(uint8_t*)"0123456789", 10}), j, j);
      if(nelua_nlstring___eq(cmp, ch)) {
        ok_digits = (ok_digits + 1);
        break;
      }
    }
  }
  if(((ok_digits == nelua_nlstring___len(str)) && (nelua_nlstring___len(str) != 0))) {
    int64_t ret = nelua_tointeger_1(str, 10);
    return (nlmulret_nlint64_nlboolean){ret, true};
  } else {
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, unable to convert `", 26}));
    nelua_filestream_write_1((&nelua_io_stderr), str);
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"` to an integer from base 10.\n", 30}));
    return (nlmulret_nlint64_nlboolean){0, false};
  }
}
nlmulret_nlint64_nlboolean utils_check_hex(nlstring str) {
  int64_t ok_digits = 0;
  for(intptr_t i = 1, _end = nelua_nlstring___len(str); i <= _end; i += 1) {
    nlstring ch = nelua_nlstring_sub_1(str, i, i);
    for(intptr_t j = 1, _end = nelua_nlstring___len(((nlstring){(uint8_t*)"0123456789abcdefABCDEF", 22})); j <= _end; j += 1) {
      nlstring cmp = nelua_nlstring_sub_1(((nlstring){(uint8_t*)"0123456789abcdefABCDEF", 22}), j, j);
      if(nelua_nlstring___eq(cmp, ch)) {
        ok_digits = (ok_digits + 1);
        break;
      }
    }
  }
  if(((ok_digits == nelua_nlstring___len(str)) && (nelua_nlstring___len(str) != 0))) {
    int64_t ret = nelua_tointeger_1(str, 16);
    return (nlmulret_nlint64_nlboolean){ret, true};
  } else {
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, unable to convert `", 26}));
    nelua_filestream_write_1((&nelua_io_stderr), str);
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"` to an integer from base 16.\n", 30}));
    return (nlmulret_nlint64_nlboolean){0, false};
  }
}
nlmulret_nlint64_nlboolean utils_check_integer(nlstring str) {
  if((nelua_nlstring___len(str) < 3)) {
    nlmulret_nlint64_nlboolean _ret_1 = utils_check_decimal(str);
    return (nlmulret_nlint64_nlboolean){_ret_1.r1, _ret_1.r2};
  }
  if(nelua_nlstring___eq(nelua_nlstring_sub_1(str, 1, 2), ((nlstring){(uint8_t*)"0x", 2}))) {
    nlmulret_nlint64_nlboolean _mulret_1;
    nlmulret_nlint64_nlboolean _ret_2 = utils_check_hex(nelua_nlstring_sub_1(str, 3, nelua_nlstring___len(str)));
    _mulret_1.r1 = _ret_2.r1;
    _mulret_1.r2 = _ret_2.r2;
    return _mulret_1;
  }
  nlmulret_nlint64_nlboolean _ret_3 = utils_check_decimal(str);
  return (nlmulret_nlint64_nlboolean){_ret_3.r1, _ret_3.r2};
}
void nelua_require_utils(nlniltype modname) {
  nelua_require_io_cached(NELUA_NIL);
}
void nelua_require_utils_cached(nlniltype modname) {
  static bool loaded = false;
  if(!loaded) {
    nelua_require_utils(NELUA_NIL);
    loaded = true;
  }
}
int64_t parser_pure_line___len(parser_pure_line_ptr self) {
  return self->len;
}
int64_t nelua_assert_bounds_nlint64(int64_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len || index < 0)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
nlstring parser_pure_line___index(parser_pure_line_ptr self, int64_t i) {
  return self->content[nelua_assert_bounds_nlint64(i, 50)];
}
nlstring parser_pure_line___tostring(parser_pure_line_ptr self) {
  nelua_stringbuilderT builder = (nelua_stringbuilderT){0};
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"len = ", 6}));
  nelua_stringbuilderT_write_2((&builder), parser_pure_line___len(self));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"; {", 3}));
  for(int64_t i = 0, _end = parser_pure_line___len(self); i < _end; i += 1) {
    nelua_stringbuilderT_write_1((&builder), parser_pure_line___index(self, i));
    if((i != (parser_pure_line___len(self) - 1))) {
      nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)", ", 2}));
    }
  }
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"}", 1}));
  return nelua_stringbuilderT_promote((&builder));
}
intptr_t parser_pure_file___len(parser_pure_file_ptr self) {
  return nelua_vector_pure_line____len((&self->content));
}
uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from int64 to usize failed");
  }
  return (uintptr_t)x;
}
parser_pure_line parser_pure_file___index(parser_pure_file_ptr self, int64_t i) {
  return (*(parser_pure_line*)nelua_assert_deref(nelua_vector_pure_line____atindex((&self->content), nelua_assert_narrow_nlint64_nlusize(i))));
}
void parser_pure_file_push_line(parser_pure_file_ptr self, parser_pure_line line) {
  nelua_vector_pure_line__push((&self->content), line);
}
void parser_pure_file_push_file(parser_pure_file_ptr self, parser_pure_file file) {
  for(intptr_t i = 0, _end = parser_pure_file___len((&file)); i < _end; i += 1) {
    parser_pure_file_push_line(self, parser_pure_file___index((&file), (int64_t)i));
  }
}
parser_pure_file parser_pure_file_sub(parser_pure_file_ptr self, int64_t start, int64_t stop) {
  parser_pure_file ret = (parser_pure_file){0};
  if((stop >= start)) {
    for(int64_t i = start, _end = stop; i <= _end; i += 1) {
      parser_pure_file_push_line((&ret), parser_pure_file___index(self, i));
    }
  }
  return ret;
}
parser_pure_file parser_pure_file_copy(parser_pure_file_ptr self) {
  return parser_pure_file_sub(self, 0, (int64_t)(parser_pure_file___len(self) - 1));
}
parser_pure_file parser_pure_file_word_swap(parser_pure_file_ptr self, int64_t i, int64_t j, nlstring new_str) {
  parser_pure_file ret = parser_pure_file_sub(self, 0, (i - 1));
  parser_pure_line interesting_line = parser_pure_file___index(self, i);
  interesting_line.content[nelua_assert_bounds_nlint64(j, 50)] = new_str;
  parser_pure_file_push_line((&ret), interesting_line);
  parser_pure_file_push_file((&ret), parser_pure_file_sub(self, (i + 1), (int64_t)(parser_pure_file___len(self) - 1)));
  return ret;
}
bool parser_is_whitespace(nlstring s) {
  uint8_t c = nelua_nlstring_byte_1(s, NELUA_NIL);
  return (!((c > 0x20) && (c < 0x7f)));
}
parser_pure_line parser_purify_line(nlstring s) {
  bool in_word = false;
  parser_pure_line ret = (parser_pure_line){0};
  ret.len = 0;
  ret.raw = s;
  int64_t pointer_1 = 1;
  int64_t curr_word_start = 0;
  while(((pointer_1 <= nelua_nlstring___len(s)) && (parser_pure_line___len((&ret)) < 49))) {
    nlstring curr_char = nelua_nlstring_sub_1(s, (intptr_t)pointer_1, (intptr_t)pointer_1);
    if(nelua_nlstring___eq(curr_char, ((nlstring){(uint8_t*)";", 1}))) {
      break;
    }
    if(in_word) {
      if(parser_is_whitespace(curr_char)) {
        ret.content[nelua_assert_bounds_nlint64(parser_pure_line___len((&ret)), 50)] = nelua_nlstring_sub_1(s, (intptr_t)curr_word_start, (intptr_t)(pointer_1 - 1));
        ret.len = (parser_pure_line___len((&ret)) + 1);
        in_word = false;
      }
    } else {
      if((!parser_is_whitespace(curr_char))) {
        in_word = true;
        curr_word_start = pointer_1;
      }
    }
    pointer_1 = (pointer_1 + 1);
  }
  if(in_word) {
    ret.content[nelua_assert_bounds_nlint64(parser_pure_line___len((&ret)), 50)] = nelua_nlstring_sub_1(s, (intptr_t)curr_word_start, (intptr_t)(pointer_1 - 1));
    ret.len = (parser_pure_line___len((&ret)) + 1);
  }
  return ret;
}
parser_pure_file parser_purify_string(nlstring s) {
  parser_pure_file ret = (parser_pure_file){0};
  intptr_t line_start = 1;
  for(intptr_t i = 1, _end = nelua_nlstring___len(s); i <= _end; i += 1) {
    if(nelua_nlstring___eq(nelua_nlstring_sub_1(s, i, i), ((nlstring){(uint8_t*)"\n", 1}))) {
      if(((i - 1) >= line_start)) {
        nelua_vector_pure_line__push((&ret.content), parser_purify_line(nelua_nlstring_sub_1(s, line_start, (i - 1))));
      } else {
        nelua_vector_pure_line__push((&ret.content), parser_purify_line(((nlstring){(uint8_t*)"", 0})));
      }
      line_start = (i + 1);
    }
  }
  if((nelua_nlstring___len(s) >= line_start)) {
    nelua_vector_pure_line__push((&ret.content), parser_purify_line(nelua_nlstring_sub_1(s, line_start, nelua_nlstring___len(s))));
  }
  return ret;
}
parser_pure_file parser_purify_file(nelua_filestream file) {
  nlstring s = nelua_filestream_read_1((&file), ((nlstring){(uint8_t*)"a", 1})).r1;
  nelua_filestream_close((&file));
  return parser_purify_string(s);
}
bool macro_check_arg_formed_OK(macro_macro m) {
  for(intptr_t i = 0, _end = parser_pure_file___len((&m.content)); i < _end; i += 1) {
    parser_pure_line curr_line = parser_pure_file___index((&m.content), (int64_t)i);
    for(int64_t j = 0, _end = parser_pure_line___len((&curr_line)); j < _end; j += 1) {
      nlstring curr_word = parser_pure_line___index((&curr_line), j);
      if(nelua_nlstring___eq(nelua_nlstring_sub_1(curr_word, 1, 1), ((nlstring){(uint8_t*)"$", 1}))) {
        if((nelua_nlstring___len(curr_word) == 1)) {
          return false;
        }
        nlmulret_nlint64_nlboolean _asgnret_1 = utils_check_integer(nelua_nlstring_sub_1(curr_word, 2, nelua_nlstring___len(curr_word)));
        int64_t arg_num = _asgnret_1.r1;
        bool conv_ok = _asgnret_1.r2;
        if(((arg_num < 1) || (!conv_ok))) {
          return false;
        }
      }
    }
  }
  return true;
}
uintptr_t nelua_assert_narrow_nlisize_nlusize(intptr_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from isize to usize failed");
  }
  return (uintptr_t)x;
}
bool macro_check_arg_use_OK(macro_macro m) {
  nelua_vector_boolean_ list_used_args = (nelua_vector_boolean_){0};
  for(int64_t i = 0, _end = m.number_of_args; i < _end; i += 1) {
    nelua_vector_boolean__push((&list_used_args), false);
  }
  for(intptr_t i = 0, _end = parser_pure_file___len((&m.content)); i < _end; i += 1) {
    parser_pure_line curr_line = parser_pure_file___index((&m.content), (int64_t)i);
    for(int64_t j = 0, _end = parser_pure_line___len((&curr_line)); j < _end; j += 1) {
      nlstring curr_word = parser_pure_line___index((&curr_line), j);
      if(nelua_nlstring___eq(nelua_nlstring_sub_1(curr_word, 1, 1), ((nlstring){(uint8_t*)"$", 1}))) {
        nlmulret_nlint64_nlboolean _asgnret_1 = utils_check_integer(nelua_nlstring_sub_1(curr_word, 2, nelua_nlstring___len(curr_word)));
        int64_t arg_num = _asgnret_1.r1;
        bool conv_ok = _asgnret_1.r2;
        if(((arg_num > m.number_of_args) || (!conv_ok))) {
          return false;
        }
        (*(bool*)nelua_assert_deref(nelua_vector_boolean____atindex((&list_used_args), nelua_assert_narrow_nlint64_nlusize((arg_num - 1))))) = true;
      }
    }
  }
  for(intptr_t i = 0, _end = nelua_vector_boolean____len((&list_used_args)); i < _end; i += 1) {
    if((!(*(bool*)nelua_assert_deref(nelua_vector_boolean____atindex((&list_used_args), nelua_assert_narrow_nlisize_nlusize(i)))))) {
      return false;
    }
  }
  return true;
}
bool macro_register_macro(nlstring name, int64_t number_of_args, parser_pure_file content) {
  for(intptr_t i = 0, _end = nelua_vector_macro____len((&macro_list)); i < _end; i += 1) {
    if(nelua_nlstring___eq((*(macro_macro*)nelua_assert_deref(nelua_vector_macro____atindex((&macro_list), nelua_assert_narrow_nlisize_nlusize(i)))).name, name)) {
      nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, a macro with the name ", 29}));
      nelua_filestream_write_1((&nelua_io_stderr), name);
      nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)" already registered.\n", 21}));
      return false;
    }
  }
  macro_macro try_macro = (macro_macro){name, number_of_args, content};
  bool ret = (macro_check_arg_formed_OK(try_macro) && macro_check_arg_use_OK(try_macro));
  if(ret) {
    nelua_vector_macro__push((&macro_list), try_macro);
  }
  return ret;
}
nlmulret_parser_pure_file_nlint64 macro_expend_macro(parser_pure_line line) {
  parser_pure_file ret = (parser_pure_file){0};
  macro_macro target_macro = (macro_macro){0};
  bool target_found = false;
  for(intptr_t i = 0, _end = nelua_vector_macro____len((&macro_list)); i < _end; i += 1) {
    if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), (*(macro_macro*)nelua_assert_deref(nelua_vector_macro____atindex((&macro_list), nelua_assert_narrow_nlisize_nlusize(i)))).name)) {
      target_found = true;
      target_macro = (*(macro_macro*)nelua_assert_deref(nelua_vector_macro____atindex((&macro_list), nelua_assert_narrow_nlisize_nlusize(i))));
      break;
    }
  }
  if((!target_found)) {
    return (nlmulret_parser_pure_file_nlint64){ret, macro_EXP_MACRO_ERR_NOT_FOUND};
  }
  if((parser_pure_line___len((&line)) != (target_macro.number_of_args + 1))) {
    return (nlmulret_parser_pure_file_nlint64){ret, macro_EXP_MACRO_ERR_INVALID_ARG};
  }
  ret = parser_pure_file_copy((&target_macro.content));
  for(intptr_t i = 0, _end = parser_pure_file___len((&ret)); i < _end; i += 1) {
    parser_pure_line curr_line = parser_pure_file___index((&ret), (int64_t)i);
    for(int64_t j = 0, _end = parser_pure_line___len((&curr_line)); j < _end; j += 1) {
      nlstring curr_word = parser_pure_line___index((&curr_line), j);
      if(nelua_nlstring___eq(nelua_nlstring_sub_1(curr_word, 1, 1), ((nlstring){(uint8_t*)"$", 1}))) {
        nlmulret_nlint64_nlboolean _asgnret_1 = utils_check_integer(nelua_nlstring_sub_1(curr_word, 2, nelua_nlstring___len(curr_word)));
        int64_t arg_num = _asgnret_1.r1;
        if((!true)) {
          return (nlmulret_parser_pure_file_nlint64){ret, macro_EXP_MACRO_ERR_MALFORMED_NUMBER};
        }
        ret = parser_pure_file_word_swap((&ret), (int64_t)i, j, parser_pure_line___index((&line), arg_num));
      }
    }
  }
  return (nlmulret_parser_pure_file_nlint64){ret, macro_EXP_MACRO_ERR_OK};
}
bool macro_is_macro(nlstring name) {
  for(intptr_t i = 0, _end = nelua_vector_macro____len((&macro_list)); i < _end; i += 1) {
    if(nelua_nlstring___eq((*(macro_macro*)nelua_assert_deref(nelua_vector_macro____atindex((&macro_list), nelua_assert_narrow_nlisize_nlusize(i)))).name, name)) {
      return true;
    }
  }
  return false;
}
void nelua_require_macro(nlniltype modname) {
  nelua_require_io_cached(NELUA_NIL);
}
intptr_t nelua_assert_bounds_nlisize(intptr_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len || index < 0)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
bool assemble_line_is_mnemonic_valid(nlstring mnemonic) {
  nlstring mnemonic_UP = nelua_nlstring_upper(mnemonic);
  for(intptr_t i = 0; i < 28; i += 1) {
    if(nelua_nlstring___eq(mnemonic_UP, assemble_line_instruction_list.v[nelua_assert_bounds_nlisize(i, 28)].mnemonic)) {
      return true;
    }
  }
  return false;
}
assemble_line_instruction assemble_line_get_inst(nlstring mnemonic) {
  nlstring mnemonic_UP = nelua_nlstring_upper(mnemonic);
  for(intptr_t i = 0; i < 28; i += 1) {
    if(nelua_nlstring___eq(mnemonic_UP, assemble_line_instruction_list.v[nelua_assert_bounds_nlisize(i, 28)].mnemonic)) {
      return assemble_line_instruction_list.v[nelua_assert_bounds_nlisize(i, 28)];
    }
  }
  return assemble_line_get_inst(((nlstring){(uint8_t*)"SLP", 3}));
}
bool assemble_line_is_reg_valid(nlstring reg) {
  nlstring reg_UP = nelua_nlstring_upper(reg);
  if((((nelua_nlstring___eq(reg_UP, ((nlstring){(uint8_t*)"WR", 2})) || nelua_nlstring___eq(reg_UP, ((nlstring){(uint8_t*)"SR", 2}))) || nelua_nlstring___eq(reg_UP, ((nlstring){(uint8_t*)"PC", 2}))) || nelua_nlstring___eq(reg_UP, ((nlstring){(uint8_t*)"SP", 2})))) {
    return true;
  }
  if(((nelua_nlstring___len(reg) != 2) && (nelua_nlstring___len(reg) != 3))) {
    return false;
  }
  if((!nelua_nlstring___eq(nelua_nlstring_sub_1(reg_UP, 1, 1), ((nlstring){(uint8_t*)"R", 1})))) {
    return false;
  }
  nlstring number_1 = (nlstring){0};
  if((nelua_nlstring___len(reg) == 2)) {
    number_1 = nelua_nlstring___concat_2(((nlstring){(uint8_t*)"0x", 2}), nelua_nlstring_sub_1(reg, 2, nelua_nlstring___len(reg)));
  } else {
    number_1 = nelua_nlstring_sub_1(reg, 2, nelua_nlstring___len(reg));
  }
  nlmulret_nlint64_nlboolean _asgnret_1 = utils_check_integer(number_1);
  int64_t true_num = _asgnret_1.r1;
  bool conv_ok = _asgnret_1.r2;
  if((((true_num < 0) || (true_num > 15)) || (!conv_ok))) {
    return false;
  }
  return true;
}
uint8_t assemble_line_reg_to_num(nlstring reg) {
  nlstring reg_UP = nelua_nlstring_upper(reg);
  if(nelua_nlstring___eq(reg_UP, ((nlstring){(uint8_t*)"WR", 2}))) {
    return 0U;
  }
  if(nelua_nlstring___eq(reg_UP, ((nlstring){(uint8_t*)"SR", 2}))) {
    return 13U;
  }
  if(nelua_nlstring___eq(reg_UP, ((nlstring){(uint8_t*)"PC", 2}))) {
    return 14U;
  }
  if(nelua_nlstring___eq(reg_UP, ((nlstring){(uint8_t*)"SP", 2}))) {
    return 15U;
  }
  nlstring number_2 = (nlstring){0};
  if((nelua_nlstring___len(reg) == 2)) {
    number_2 = nelua_nlstring___concat_2(((nlstring){(uint8_t*)"0x", 2}), nelua_nlstring_sub_1(reg, 2, nelua_nlstring___len(reg)));
  } else {
    number_2 = nelua_nlstring_sub_1(reg, 2, nelua_nlstring___len(reg));
  }
  int64_t ret = utils_check_integer(number_2).r1;
  return (uint8_t)ret;
}
bool assemble_line_is_line_valid(parser_pure_line line) {
  if((parser_pure_line___len((&line)) > 2)) {
    return false;
  }
  if((!assemble_line_is_mnemonic_valid(parser_pure_line___index((&line), 0)))) {
    return false;
  }
  assemble_line_instruction inst = assemble_line_get_inst(parser_pure_line___index((&line), 0));
  if(((inst.argument == 0) && (parser_pure_line___len((&line)) == 2))) {
    return false;
  }
  if((inst.argument == 1)) {
    if((!assemble_line_is_reg_valid(parser_pure_line___index((&line), 1)))) {
      return false;
    }
  }
  if((inst.argument == 2)) {
    nlmulret_nlint64_nlboolean _asgnret_1 = utils_check_integer(parser_pure_line___index((&line), 1));
    int64_t arg_num = _asgnret_1.r1;
    bool conv_ok = _asgnret_1.r2;
    if((((0 > arg_num) || (arg_num > 3)) || (!conv_ok))) {
      return false;
    }
  }
  if((inst.argument == 3)) {
    nlmulret_nlint64_nlboolean _asgnret_2 = utils_check_integer(parser_pure_line___index((&line), 1));
    int64_t arg_num = _asgnret_2.r1;
    bool conv_ok = _asgnret_2.r2;
    if((((0 > arg_num) || (arg_num > 15)) || (!conv_ok))) {
      return false;
    }
  }
  return true;
}
uint8_t nelua_assert_narrow_nlint64_nluint8(int64_t x) {
  if(NELUA_UNLIKELY(x < 0 || x > 0xff)) {
    nelua_panic_cstring("narrow casting from int64 to uint8 failed");
  }
  return (uint8_t)x;
}
uint8_t assemble_line_asm_line(parser_pure_line line) {
  uint8_t ret = 0U;
  assemble_line_instruction inst = assemble_line_get_inst(parser_pure_line___index((&line), 0));
  if((inst.argument == 0)) {
    ret = inst.opcode;
  } else if((inst.argument == 1)) {
    ret = ((inst.opcode << 4) | assemble_line_reg_to_num(parser_pure_line___index((&line), 1)));
  } else if((inst.argument == 2)) {
    ret = nelua_assert_narrow_nlint64_nluint8((int64_t)((inst.opcode << 2) | utils_check_integer(parser_pure_line___index((&line), 1)).r1));
  } else if((inst.argument == 3)) {
    ret = nelua_assert_narrow_nlint64_nluint8((int64_t)((inst.opcode << 4) | utils_check_integer(parser_pure_line___index((&line), 1)).r1));
  }
  return ret;
}
nlmulret_nluint8_nlint64_nlstring assemble_line_assemble_line(parser_pure_line line) {
  bool OK = assemble_line_is_line_valid(line);
  if((!OK)) {
    return (nlmulret_nluint8_nlint64_nlstring){0U, 1, ((nlstring){(uint8_t*)"Error!", 6})};
  }
  nlmulret_nluint8_nlint64_nlstring _mulret_1;
  _mulret_1.r1 = assemble_line_asm_line(line);
  _mulret_1.r2 = 0;
  _mulret_1.r3 = nelua_tostring_1(line);
  return _mulret_1;
}
void nelua_require_assemble_line(nlniltype modname) {
  nelua_require_io_cached(NELUA_NIL);
  nelua_require_utils_cached(NELUA_NIL);
}
assembler_block assembler_make_pure_file_block(assembler_pure_file_block in_block) {
  assembler_block ret = (assembler_block){0};
  ret.type = 1;
  ret.content.pure_file = in_block;
  return ret;
}
nelua_vector_block_ assembler_delete_block(nelua_vector_block_ in_block, int64_t i) {
  if(((i < 0) || (i >= nelua_vector_block____len((&in_block))))) {
    nelua_panic_string(((nlstring){(uint8_t*)"In delete_block, invalid range.\n", 32}));
  }
  nelua_vector_block_ ret = (nelua_vector_block_){0};
  for(intptr_t j = 0, _end = nelua_vector_block____len((&in_block)); j < _end; j += 1) {
    if((j != i)) {
      nelua_vector_block__push((&ret), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(j)))));
    }
  }
  return ret;
}
nelua_vector_block_ assembler_insert_block(nelua_vector_block_ in_block, int64_t i, assembler_block new_1) {
  if(((i < 0) || (i > nelua_vector_block____len((&in_block))))) {
    nelua_panic_string(((nlstring){(uint8_t*)"In insert_block, invalid range.\n", 32}));
  }
  nelua_vector_block_ ret = (nelua_vector_block_){0};
  for(intptr_t j = 0, _end = nelua_vector_block____len((&in_block)); j < _end; j += 1) {
    if((j == i)) {
      nelua_vector_block__push((&ret), new_1);
    }
    nelua_vector_block__push((&ret), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(j)))));
  }
  if((i == nelua_vector_block____len((&in_block)))) {
    nelua_vector_block__push((&ret), new_1);
  }
  return ret;
}
nelua_vector_block_ assembler_swap_block(nelua_vector_block_ in_block, int64_t i, assembler_block new_2) {
  if(((i < 0) || (i >= nelua_vector_block____len((&in_block))))) {
    nelua_panic_string(((nlstring){(uint8_t*)"In swap_block, invalid range.\n", 30}));
  }
  nelua_vector_block_ ret = (nelua_vector_block_){0};
  for(intptr_t j = 0, _end = nelua_vector_block____len((&in_block)); j < _end; j += 1) {
    if((j == i)) {
      nelua_vector_block__push((&ret), new_2);
    } else {
      nelua_vector_block__push((&ret), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(j)))));
    }
  }
  return ret;
}
nelua_vector_block_ assembler_slice_pure_file_block(nelua_vector_block_ in_block, int64_t i, int64_t line_start, int64_t line_stop) {
  if((i < 0)) {
    nelua_panic_string(((nlstring){(uint8_t*)"In slice_pure_file_block, i is too small.\n", 42}));
  }
  if((i >= nelua_vector_block____len((&in_block)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"In slice_pure_file_block, i is too big.\n", 40}));
  }
  if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).type != 1)) {
    nelua_panic_string(((nlstring){(uint8_t*)"In slice_pure_file_block, invalid type.\n", 40}));
  }
  assembler_pure_file_block file = (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file;
  if((((line_start > line_stop) || (line_start < 0)) || (line_stop >= parser_pure_file___len((&file.content))))) {
    nelua_panic_string(((nlstring){(uint8_t*)"In slice_pure_file_block, invalid range.\n", 41}));
  }
  parser_pure_file start_file = parser_pure_file_sub((&(*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.content), 0, (line_start - 1));
  parser_pure_file end_file = parser_pure_file_sub((&(*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.content), (line_stop + 1), (int64_t)(parser_pure_file___len((&(*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.content)) - 1));
  assembler_pure_file_block start_block = (assembler_pure_file_block){start_file, (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.name, (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.place, (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.is_macro, (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.dir};
  assembler_pure_file_block end_block = (assembler_pure_file_block){end_file, (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.name, (((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.place + line_stop) + 1), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.is_macro, (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i)))).content.pure_file.dir};
  nelua_vector_block_ ret = assembler_swap_block(in_block, i, assembler_make_pure_file_block(start_block));
  ret = assembler_insert_block(ret, (i + 1), assembler_make_pure_file_block(end_block));
  return ret;
}
nelua_vector_block_ assembler_insert_block_in_file(nelua_vector_block_ in_block, int64_t file_index, int64_t line, assembler_block new_block) {
  nelua_vector_block_ ret = assembler_slice_pure_file_block(in_block, file_index, line, line);
  ret = assembler_insert_block(ret, (file_index + 1), new_block);
  return ret;
}
void assembler_error_in_file(assembler_pure_file_block in_block, int64_t i) {
  nelua_stringbuilderT builder = (nelua_stringbuilderT){0};
  if(in_block.is_macro) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"Error in macro `", 16}));
  } else {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"Error in file `", 15}));
  }
  nelua_stringbuilderT_write_1((&builder), in_block.name);
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"`, line ", 8}));
  nelua_stringbuilderT_write_2((&builder), (in_block.place + i));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)".\n", 2}));
  nelua_filestream_write_1((&nelua_io_stderr), nelua_stringbuilderT_promote((&builder)));
}
nlstring assembler_dir(nlstring filename) {
  for(int64_t i = (int64_t)nelua_nlstring___len(filename); i >= 1; i += -1) {
    if(nelua_nlstring___eq(nelua_nlstring_sub_1(filename, (intptr_t)i, (intptr_t)i), ((nlstring){(uint8_t*)"/", 1}))) {
      return nelua_nlstring_sub_1(filename, 1, (intptr_t)i);
    }
  }
  return ((nlstring){(uint8_t*)"", 0});
}
nlmulret_assembler_pure_file_block_assembler_error_t assembler_open_file_block(nlstring filename) {
  assembler_pure_file_block ret = (assembler_pure_file_block){0};
  nlmulret_nelua_filestream_nlstring_nlint64 _asgnret_1 = nelua_io_open_1(filename, ((nlstring){(uint8_t*)"r", 1}));
  nelua_filestream f = _asgnret_1.r1;
  int64_t err = _asgnret_1.r3;
  if((err != 0)) {
    return (nlmulret_assembler_pure_file_block_assembler_error_t){ret, 1};
  }
  ret.content = parser_purify_file(f);
  ret.name = filename;
  ret.place = 1;
  ret.is_macro = false;
  ret.dir = assembler_dir(filename);
  return (nlmulret_assembler_pure_file_block_assembler_error_t){ret, 0};
}
nlmulret_nelua_vector_block__assembler_error_t assembler_first_step(nelua_vector_block_ in_block, int64_t addr_size) {
  nelua_vector_block_ ret = nelua_vector_block__copy((&in_block));
  for(intptr_t i = 0, _end = nelua_vector_block____len((&in_block)); i < _end; i += 1) {
    if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 1)) {
      parser_pure_file file = (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file.content;
      for(intptr_t j = 0, _end = parser_pure_file___len((&file)); j < _end; j += 1) {
        parser_pure_line line = parser_pure_file___index((&file), (int64_t)j);
        if((parser_pure_line___len((&line)) == 0)) {
          continue;
        }
        if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@import", 7}))) {
          if((parser_pure_line___len((&line)) != 2)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for an import directive.\n", 53}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          nlmulret_assembler_pure_file_block_assembler_error_t _asgnret_1 = assembler_open_file_block(nelua_nlstring___concat_2((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file.dir, parser_pure_line___index((&line), 1)));
          assembler_pure_file_block imported_file = _asgnret_1.r1;
          assembler_error_t err = _asgnret_1.r2;
          if((err != 0)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Unable to open ", 15}), parser_pure_line___index((&line), 1), ((nlstring){(uint8_t*)".\n", 2}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, err};
          }
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, assembler_make_pure_file_block(imported_file));
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        }
      }
    }
  }
  return (nlmulret_nelua_vector_block__assembler_error_t){ret, 0};
}
int64_t nelua_shr_nlint64(int64_t a, int64_t b) {
  if(NELUA_LIKELY(b >= 0 && b < 64)) {
    return (uint64_t)a >> b;
  } else if(NELUA_UNLIKELY(b < 0 && b > -64)) {
    return (uint64_t)a << -b;
  } else {
    return 0;
  }
}
nlmulret_assembler_block_assembler_error_t assembler_gen_set8(int64_t num) {
  if(((num & -256) != 0)) {
    nlmulret_assembler_block_assembler_error_t _mulret_1;
    _mulret_1.r1 = assembler_make_pure_file_block((assembler_pure_file_block){parser_purify_string(((nlstring){(uint8_t*)"", 0})), {(uint8_t*)"", 0}, 1, false, {(uint8_t*)"", 0}});
    _mulret_1.r2 = 3;
    return _mulret_1;
  }
  nelua_stringbuilderT builder = (nelua_stringbuilderT){0};
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"set 4\n", 6}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"cpy R12\n", 8}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"set ", 4}));
  nelua_stringbuilderT_write_2((&builder), nelua_shr_nlint64((num & 0xf0), 4));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"lsl R12\n", 8}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"cpy R12\n", 8}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"set ", 4}));
  nelua_stringbuilderT_write_2((&builder), (num & 0xf));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"or R12\n", 7}));
  parser_pure_file code_block = parser_purify_string(nelua_stringbuilderT_promote((&builder)));
  assembler_pure_file_block local_block = (assembler_pure_file_block){code_block, {(uint8_t*)"set8", 4}, 1, true, {(uint8_t*)".", 1}};
  return (nlmulret_assembler_block_assembler_error_t){assembler_make_pure_file_block(local_block), 0};
}
nlmulret_nelua_vector_block__assembler_error_t assembler_second_step(nelua_vector_block_ in_block, int64_t addr_size) {
  nelua_vector_block_ ret = nelua_vector_block__copy((&in_block));
  for(intptr_t i = 0, _end = nelua_vector_block____len((&ret)); i < _end; i += 1) {
    if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).type == 1)) {
      parser_pure_file file = (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file.content;
      for(intptr_t j = 0, _end = parser_pure_file___len((&file)); j < _end; j += 1) {
        parser_pure_line line = parser_pure_file___index((&file), (int64_t)j);
        if((parser_pure_line___len((&line)) == 0)) {
          continue;
        }
        if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@define", 7}))) {
          if((parser_pure_line___len((&line)) != 3)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for a define directive.\n", 52}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          intptr_t end_label = j;
          while(true) {
            if((end_label >= parser_pure_file___len((&file)))) {
              assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
              nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Macro ", 6}), parser_pure_line___index((&line), 1), ((nlstring){(uint8_t*)" should finish with @end.\n", 26}));
              return (nlmulret_nelua_vector_block__assembler_error_t){ret, 7};
            }
            parser_pure_line line_1 = parser_pure_file___index((&file), (int64_t)end_label);
            if(nelua_nlstring___eq(parser_pure_line___index((&line_1), 0), ((nlstring){(uint8_t*)"@end", 4}))) {
              break;
            }
            end_label = (end_label + 1);
          }
          parser_pure_file macro_1 = parser_pure_file_sub((&file), (int64_t)(j + 1), (int64_t)(end_label - 1));
          nlmulret_nlint64_nlboolean _asgnret_1 = utils_check_integer(parser_pure_line___index((&line), 2));
          int64_t number_of_args = _asgnret_1.r1;
          bool conv_ok = _asgnret_1.r2;
          if((!conv_ok)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 9};
          }
          bool macro_ok = macro_register_macro(parser_pure_line___index((&line), 1), number_of_args, macro_1);
          if((!macro_ok)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Macro ", 6}), parser_pure_line___index((&line), 1), ((nlstring){(uint8_t*)" could not be registered.\n", 26}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 7};
          }
          ret = assembler_slice_pure_file_block(ret, (int64_t)i, (int64_t)j, (int64_t)end_label);
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        } else if(macro_is_macro(parser_pure_line___index((&line), 0))) {
          nlmulret_parser_pure_file_nlint64 _asgnret_2 = macro_expend_macro(line);
          parser_pure_file macro_2 = _asgnret_2.r1;
          int64_t err = _asgnret_2.r2;
          if((err == macro_EXP_MACRO_ERR_INVALID_ARG)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for macro", 37}), parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)".\n", 2}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 7};
          }
          assembler_pure_file_block macro_block = (assembler_pure_file_block){macro_2, parser_pure_line___index((&line), 0), 1, true, {(uint8_t*)"", 0}};
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, assembler_make_pure_file_block(macro_block));
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        } else if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@set8", 5}))) {
          if((parser_pure_line___len((&line)) != 2)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for a set8 directive.\n", 50}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          nlmulret_nlint64_nlboolean _asgnret_3 = utils_check_integer(parser_pure_line___index((&line), 1));
          int64_t int_ = _asgnret_3.r1;
          bool int_ok = _asgnret_3.r2;
          if((!int_ok)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Argument for set8 shold be a number.\n", 37}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          nlmulret_assembler_block_assembler_error_t _asgnret_4 = assembler_gen_set8(int_);
          assembler_block set8 = _asgnret_4.r1;
          assembler_error_t err = _asgnret_4.r2;
          if((err != 0)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Argument for set8 takes more than 8 bits.\n", 42}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, set8);
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        } else if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@label", 6}))) {
          if((parser_pure_line___len((&line)) != 2)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for a label directive.\n", 51}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          assembler_label_block lab_blk = (assembler_label_block){parser_pure_line___index((&line), 1), true};
          assembler_block new_block = (assembler_block){0};
          new_block.type = 7;
          new_block.content.label = lab_blk;
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, new_block);
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        } else if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@labref", 7}))) {
          if((parser_pure_line___len((&line)) != 2)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for a labref directive.\n", 52}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          assembler_label_block lab_blk = (assembler_label_block){parser_pure_line___index((&line), 1), false};
          assembler_block new_block = (assembler_block){0};
          new_block.type = 7;
          new_block.content.label = lab_blk;
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, new_block);
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        } else if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@align", 6}))) {
          if((parser_pure_line___len((&line)) != 2)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for a align directive.\n", 51}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          nlmulret_nlint64_nlboolean _asgnret_5 = utils_check_integer(parser_pure_line___index((&line), 1));
          int64_t num = _asgnret_5.r1;
          bool conv_ok = _asgnret_5.r2;
          if((!conv_ok)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 9};
          }
          assembler_alignment_directive_block lab_blk = (assembler_alignment_directive_block){num};
          assembler_block new_block = (assembler_block){0};
          new_block.type = 3;
          new_block.content.alignment_directive = lab_blk;
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, new_block);
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        } else if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@constant", 9}))) {
          if((parser_pure_line___len((&line)) != 2)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for a constant directive.\n", 54}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          nlmulret_nlint64_nlboolean _asgnret_6 = utils_check_integer(parser_pure_line___index((&line), 1));
          int64_t num = _asgnret_6.r1;
          bool conv_ok = _asgnret_6.r2;
          if((!conv_ok)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 9};
          }
          assembler_constant_block lab_blk = (assembler_constant_block){num};
          assembler_block new_block = (assembler_block){0};
          new_block.type = 4;
          new_block.content.constant = lab_blk;
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, new_block);
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        } else if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@rawbytes", 9}))) {
          if((parser_pure_line___len((&line)) < 2)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid number of arguments for a rawbytes directive.\n", 54}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 3};
          }
          nelua_vector_uint8_ raws = (nelua_vector_uint8_){0};
          for(int64_t i_2 = 1, _end = parser_pure_line___len((&line)); i_2 < _end; i_2 += 1) {
            nlmulret_nlint64_nlboolean _asgnret_7 = utils_check_hex(parser_pure_line___index((&line), i_2));
            int64_t num = _asgnret_7.r1;
            bool conv_ok = _asgnret_7.r2;
            if((!conv_ok)) {
              assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlint64_nlusize(i_2)))).content.pure_file, (int64_t)j);
              return (nlmulret_nelua_vector_block__assembler_error_t){ret, 9};
            }
            nelua_vector_uint8__push((&raws), nelua_assert_narrow_nlint64_nluint8(num));
          }
          assembler_rawbytes_block lab_blk = (assembler_rawbytes_block){raws};
          assembler_block new_block = (assembler_block){0};
          new_block.type = 6;
          new_block.content.rawbytes = lab_blk;
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, new_block);
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        } else if(nelua_nlstring___eq(parser_pure_line___index((&line), 0), ((nlstring){(uint8_t*)"@string", 7}))) {
          nlstring str = nelua_nlstring_sub_1(line.raw, 9, nelua_nlstring___len(line.raw));
          nelua_vector_uint8_ raws = (nelua_vector_uint8_){0};
          for(intptr_t i_3 = 1, _end = nelua_nlstring___len(str); i_3 <= _end; i_3 += 1) {
            nelua_vector_uint8__push((&raws), nelua_nlstring_byte_1(nelua_nlstring_sub_1(str, i_3, i_3), NELUA_NIL));
          }
          assembler_rawbytes_block lab_blk = (assembler_rawbytes_block){raws};
          assembler_block new_block = (assembler_block){0};
          new_block.type = 6;
          new_block.content.rawbytes = lab_blk;
          ret = assembler_insert_block_in_file(ret, (int64_t)i, (int64_t)j, new_block);
          return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
        }
      }
    }
  }
  return (nlmulret_nelua_vector_block__assembler_error_t){ret, 0};
}
nlmulret_nelua_vector_block__assembler_error_t assembler_third_step(nelua_vector_block_ in_block, int64_t addr_size) {
  nelua_vector_block_ ret = nelua_vector_block__copy((&in_block));
  for(intptr_t i = 0, _end = nelua_vector_block____len((&in_block)); i < _end; i += 1) {
    if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).type == 1)) {
      parser_pure_file file = (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file.content;
      if((parser_pure_file___len((&file)) == 0)) {
        ret = assembler_delete_block(ret, (int64_t)i);
        return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
      } else {
        nelua_vector_block_ code = (nelua_vector_block_){0};
        for(intptr_t j = 0, _end = parser_pure_file___len((&file)); j < _end; j += 1) {
          parser_pure_line line = parser_pure_file___index((&file), (int64_t)j);
          if((parser_pure_line___len((&line)) == 0)) {
            continue;
          }
          nlmulret_nluint8_nlint64_nlstring _asgnret_1 = assemble_line_assemble_line(line);
          uint8_t mc = _asgnret_1.r1;
          int64_t err = _asgnret_1.r2;
          nlstring pretty = _asgnret_1.r3;
          if((err != 0)) {
            assembler_error_in_file((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.pure_file, (int64_t)j);
            nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Invalid instruction. ", 21}), parser_pure_line___tostring((&line)), ((nlstring){(uint8_t*)"\n", 1}));
            return (nlmulret_nelua_vector_block__assembler_error_t){ret, 4};
          }
          assembler_block new_block = (assembler_block){0};
          new_block.type = 2;
          new_block.content.machine_code = (assembler_machine_code_block){mc, pretty};
          nelua_vector_block__push((&code), new_block);
        }
        ret = assembler_delete_block(ret, (int64_t)i);
        for(intptr_t j = 0, _end = nelua_vector_block____len((&code)); j < _end; j += 1) {
          ret = assembler_insert_block(ret, (int64_t)(i + j), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&code), nelua_assert_narrow_nlisize_nlusize(j)))));
        }
        return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
      }
    } else if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).type == 6)) {
      nelua_vector_uint8_ content = (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).content.rawbytes.content;
      ret = assembler_delete_block(ret, (int64_t)i);
      for(intptr_t j = 0, _end = nelua_vector_uint8____len((&content)); j < _end; j += 1) {
        assembler_block new_block = (assembler_block){0};
        new_block.type = 5;
        new_block.content.rawbyte = (assembler_rawbyte_block){(*(uint8_t*)nelua_assert_deref(nelua_vector_uint8____atindex((&content), nelua_assert_narrow_nlisize_nlusize(j))))};
        ret = assembler_insert_block(ret, (int64_t)(i + j), new_block);
      }
      return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
    } else if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).type == 4)) {
      int64_t num = (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).content.constant.content;
      nelua_vector_uint8_ vect = (nelua_vector_uint8_){0};
      for(int64_t i_4 = 0, _end = addr_size; i_4 < _end; i_4 += 1) {
        nelua_vector_uint8__push((&vect), nelua_assert_narrow_nlint64_nluint8((num & 0xff)));
        num = nelua_shr_nlint64(num, 8);
      }
      if((num != 0)) {
        nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, invalid constant: ", 25}), nelua_tostring_2((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&ret), nelua_assert_narrow_nlisize_nlusize(i)))).content.constant.content), ((nlstring){(uint8_t*)", number is too big.\n", 21}));
        return (nlmulret_nelua_vector_block__assembler_error_t){ret, 8};
      }
      assembler_block new_block = (assembler_block){0};
      new_block.type = 6;
      new_block.content.rawbytes = (assembler_rawbytes_block){vect};
      ret = assembler_swap_block(ret, (int64_t)i, new_block);
      return (nlmulret_nelua_vector_block__assembler_error_t){ret, -1};
    }
  }
  return (nlmulret_nelua_vector_block__assembler_error_t){ret, 0};
}
int64_t nelua_assert_imod_nlint64(int64_t a, int64_t b) {
  if(NELUA_UNLIKELY(b == -1)) return 0;
  if(NELUA_UNLIKELY(b == 0)) nelua_panic_cstring("division by zero");
  int64_t r = a % b;
  return (r != 0 && (a ^ b) < 0) ? r + b : r;
}
nlmulret_nelua_vector_block__assembler_error_t assembler_fourth_step(nelua_vector_block_ in_block, int64_t addr_size) {
  nelua_vector_block_ ret = (nelua_vector_block_){0};
  uint64_t curr_addr = 0U;
  for(intptr_t i = 0, _end = nelua_vector_block____len((&in_block)); i < _end; i += 1) {
    if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 7)) {
      nelua_vector_block__push((&ret), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))));
      if((!(*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.label.set)) {
        curr_addr = nelua_assert_narrow_nlint64_nluint64((int64_t)(curr_addr + addr_size));
      }
    } else if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 5)) {
      nelua_vector_block__push((&ret), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))));
      curr_addr = (curr_addr + 1);
    } else if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 2)) {
      assembler_block new_block = (assembler_block){0};
      new_block.type = 5;
      new_block.content.rawbyte = (assembler_rawbyte_block){(*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.machine_code.code};
      nelua_vector_block__push((&ret), new_block);
      curr_addr = (curr_addr + 1);
    } else if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 3)) {
      assembler_block new_block = (assembler_block){0};
      new_block.type = 5;
      new_block.content.rawbyte = (assembler_rawbyte_block){0U};
      while((nelua_assert_imod_nlint64(curr_addr, (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.alignment_directive.byte_alignment) != 0)) {
        nelua_vector_block__push((&ret), new_block);
        curr_addr = (curr_addr + 1);
      }
    } else {
      nelua_filestream_write_3((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, unexpected type (", 24}), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type, ((nlstring){(uint8_t*)") in fourth step.\n", 18}));
      return (nlmulret_nelua_vector_block__assembler_error_t){ret, 5};
    }
  }
  return (nlmulret_nelua_vector_block__assembler_error_t){ret, 0};
}
nlmulret_nelua_hashmap_string__uint64__assembler_error_t assembler_gen_label_map(nelua_vector_block_ in_block, int64_t addr_size, int64_t start_addr) {
  nelua_hashmap_string__uint64_ ret = (nelua_hashmap_string__uint64_){0};
  uint64_t curr_addr = nelua_assert_narrow_nlint64_nluint64(start_addr);
  for(intptr_t i = 0, _end = nelua_vector_block____len((&in_block)); i < _end; i += 1) {
    if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 7)) {
      assembler_label_block label = (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.label;
      if(label.set) {
        nluint64_ptr addr_pnt = nelua_hashmap_string__uint64__peek((&ret), label.id);
        if((addr_pnt == (nluint64_ptr)NULL)) {
          (*(uint64_t*)nelua_assert_deref(nelua_hashmap_string__uint64____atindex((&ret), label.id))) = curr_addr;
        } else {
          nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, label ", 13}), label.id, ((nlstring){(uint8_t*)" is set multiple times.\n", 24}));
          return (nlmulret_nelua_hashmap_string__uint64__assembler_error_t){ret, 6};
        }
      } else {
        curr_addr = nelua_assert_narrow_nlint64_nluint64((int64_t)(curr_addr + addr_size));
      }
    } else if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 5)) {
      curr_addr = (curr_addr + 1);
    } else {
      nelua_filestream_write_3((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, unexpected type (", 24}), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type, ((nlstring){(uint8_t*)") in fifth step.\n", 17}));
      return (nlmulret_nelua_hashmap_string__uint64__assembler_error_t){ret, 5};
    }
  }
  return (nlmulret_nelua_hashmap_string__uint64__assembler_error_t){ret, 0};
}
void nelua_print_1(nlstring a1) {
  if(a1.size > 0) {
    fwrite(a1.data, 1, a1.size, stdout);
  }
  fputs("\n", stdout);
  fflush(stdout);
}
void assembler_print_labels(nelua_hashmap_string__uint64_ map) {
  nelua_stringbuilderT builder = (nelua_stringbuilderT){0};
  {
    nlmulret_function_4P5kDe2bjz7NvgfuY_nelua_hashmap_iteratorT_1_nlstring _asgnret_1 = nelua_pairs_1((&map));
    function_4P5kDe2bjz7NvgfuY __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT_1 __forstate = _asgnret_1.r2;
    nlstring __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlstring_nluint64 _asgnret_2 = __fornext((&__forstate), __fornextit);
      bool __forcont = _asgnret_2.r1;
      nlstring k = _asgnret_2.r2;
      uint64_t v = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = k;
      {
        nelua_stringbuilderT_write_1((&builder), k);
        nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)" : ", 3}));
        nelua_stringbuilderT_write_1((&builder), nelua_nlstring_format_5(((nlstring){(uint8_t*)"%x\n", 3}), v));
      }
    }
  }
  nelua_print_1(nelua_stringbuilderT_promote((&builder)));
}
uint8_t nelua_assert_narrow_nluint64_nluint8(uint64_t x) {
  if(NELUA_UNLIKELY(x > 0xffU)) {
    nelua_panic_cstring("narrow casting from uint64 to uint8 failed");
  }
  return (uint8_t)x;
}
uint64_t nelua_shr_nluint64(uint64_t a, int64_t b) {
  if(NELUA_LIKELY(b >= 0 && b < 64)) {
    return (uint64_t)a >> b;
  } else if(NELUA_UNLIKELY(b < 0 && b > -64)) {
    return (uint64_t)a << -b;
  } else {
    return 0;
  }
}
nlmulret_nelua_vector_uint8__assembler_error_t assembler_fifth_step(nelua_vector_block_ in_block, int64_t addr_size, int64_t start_addr, bool dump_label) {
  nelua_vector_uint8_ ret = (nelua_vector_uint8_){0};
  nlmulret_nelua_hashmap_string__uint64__assembler_error_t _asgnret_1 = assembler_gen_label_map(in_block, addr_size, start_addr);
  nelua_hashmap_string__uint64_ map = _asgnret_1.r1;
  if(dump_label) {
    assembler_print_labels(map);
  }
  for(intptr_t i = 0, _end = nelua_vector_block____len((&in_block)); i < _end; i += 1) {
    if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 7)) {
      assembler_label_block label = (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.label;
      if((!label.set)) {
        nluint64_ptr addr_pnt = nelua_hashmap_string__uint64__peek((&map), label.id);
        if((addr_pnt == (nluint64_ptr)NULL)) {
          nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, label ", 13}), label.id, ((nlstring){(uint8_t*)" is used but never set.\n", 24}));
          return (nlmulret_nelua_vector_uint8__assembler_error_t){ret, 6};
        }
        uint64_t addr = (*(uint64_t*)nelua_assert_deref(addr_pnt));
        for(int64_t i_5 = 0, _end = addr_size; i_5 < _end; i_5 += 1) {
          nelua_vector_uint8__push((&ret), nelua_assert_narrow_nluint64_nluint8((nelua_shr_nluint64(addr, (i_5 * 8)) & 0xff)));
        }
      }
    } else if(((*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).type == 5)) {
      nelua_vector_uint8__push((&ret), (*(assembler_block*)nelua_assert_deref(nelua_vector_block____atindex((&in_block), nelua_assert_narrow_nlisize_nlusize(i)))).content.rawbyte.content);
    } else {
    }
  }
  return (nlmulret_nelua_vector_uint8__assembler_error_t){ret, 0};
}
nlmulret_nelua_vector_block__assembler_error_t assembler_run_step(nelua_vector_block_ in_block, function_5gAM6Sd4txxQ1bfQd step, int64_t addr_size) {
  nlmulret_nelua_vector_block__assembler_error_t _asgnret_1 = step(in_block, addr_size);
  nelua_vector_block_ ret = _asgnret_1.r1;
  assembler_error_t err = _asgnret_1.r2;
  while((err == -1)) {
    nlmulret_nelua_vector_block__assembler_error_t _asgnret_2 = step(ret, addr_size);
    ret = _asgnret_2.r1;
    err = _asgnret_2.r2;
  }
  return (nlmulret_nelua_vector_block__assembler_error_t){ret, err};
}
nlmulret_nelua_vector_uint8__assembler_error_t assembler_assemble(nlstring input_file, nlstring runtime_start, nlstring runtime_end, int64_t addr_size, int64_t start_addr, bool dump_label) {
  nelua_vector_uint8_ ret_err = (nelua_vector_uint8_){0};
  nlmulret_assembler_pure_file_block_assembler_error_t _asgnret_1 = assembler_open_file_block(input_file);
  assembler_pure_file_block in_file_block = _asgnret_1.r1;
  assembler_error_t err = _asgnret_1.r2;
  if((err != 0)) {
    nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, unable to open ", 22}), input_file, ((nlstring){(uint8_t*)".\n", 2}));
    return (nlmulret_nelua_vector_uint8__assembler_error_t){ret_err, err};
  }
  assembler_pure_file_block run_start_block = (assembler_pure_file_block){parser_purify_string(runtime_start), {(uint8_t*)"runtime_start", 13}, 1, true, {(uint8_t*)"", 0}};
  assembler_pure_file_block run_end_block = (assembler_pure_file_block){parser_purify_string(runtime_end), {(uint8_t*)"runtime_end", 11}, 1, true, {(uint8_t*)"", 0}};
  nelua_vector_block_ initial_vector = (nelua_vector_block_){0};
  nelua_vector_block__push((&initial_vector), assembler_make_pure_file_block(run_start_block));
  nelua_vector_block__push((&initial_vector), assembler_make_pure_file_block(in_file_block));
  nelua_vector_block__push((&initial_vector), assembler_make_pure_file_block(run_end_block));
  nlmulret_nelua_vector_block__assembler_error_t _asgnret_2 = assembler_run_step(initial_vector, assembler_first_step, addr_size);
  nelua_vector_block_ step1_vector = _asgnret_2.r1;
  assembler_error_t err1 = _asgnret_2.r2;
  if((err1 != 0)) {
    return (nlmulret_nelua_vector_uint8__assembler_error_t){ret_err, err1};
  }
  nlmulret_nelua_vector_block__assembler_error_t _asgnret_3 = assembler_run_step(step1_vector, assembler_second_step, addr_size);
  nelua_vector_block_ step2_vector = _asgnret_3.r1;
  assembler_error_t err2 = _asgnret_3.r2;
  if((err2 != 0)) {
    return (nlmulret_nelua_vector_uint8__assembler_error_t){ret_err, err2};
  }
  nlmulret_nelua_vector_block__assembler_error_t _asgnret_4 = assembler_run_step(step2_vector, assembler_third_step, addr_size);
  nelua_vector_block_ step3_vector = _asgnret_4.r1;
  assembler_error_t err3 = _asgnret_4.r2;
  if((err3 != 0)) {
    return (nlmulret_nelua_vector_uint8__assembler_error_t){ret_err, err3};
  }
  nlmulret_nelua_vector_block__assembler_error_t _asgnret_5 = assembler_fourth_step(step3_vector, addr_size);
  nelua_vector_block_ step4_vector = _asgnret_5.r1;
  assembler_error_t err4 = _asgnret_5.r2;
  if((err4 != 0)) {
    return (nlmulret_nelua_vector_uint8__assembler_error_t){ret_err, err4};
  }
  nlmulret_nelua_vector_uint8__assembler_error_t _asgnret_6 = assembler_fifth_step(step4_vector, addr_size, start_addr, dump_label);
  nelua_vector_uint8_ step5_vector = _asgnret_6.r1;
  assembler_error_t err5 = _asgnret_6.r2;
  if((err5 != 0)) {
    return (nlmulret_nelua_vector_uint8__assembler_error_t){ret_err, err5};
  }
  return (nlmulret_nelua_vector_uint8__assembler_error_t){step5_vector, 0};
}
void nelua_require_assembler(nlniltype modname) {
  nelua_require_io_cached(NELUA_NIL);
  nelua_require_utils_cached(NELUA_NIL);
  nelua_require_macro(NELUA_NIL);
  nelua_require_assemble_line(NELUA_NIL);
}
main_arg_flags main_parse_args(void) {
  main_arg_flags flags = (main_arg_flags){false, false, {(uint8_t*)"", 0}, {(uint8_t*)"", 0}, -1, true, -1, 0, false, false, false};
  int64_t i = 1;
  bool conv_ok = false;
  if((nelua_sequence_string__1___len((&nelua_arg)) == 0)) {
    flags.help = true;
  }
  while((i <= nelua_sequence_string__1___len((&nelua_arg)))) {
    if((((nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-h", 2})) || nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-help", 5}))) || nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"--help", 6}))) || nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"help", 4})))) {
      flags.help = true;
    } else if(nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-word-size", 10}))) {
      if((i == nelua_sequence_string__1___len((&nelua_arg)))) {
        flags.error = true;
      } else {
        nlmulret_nlint64_nlboolean _asgnret_1 = utils_check_integer((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize((i + 1))))));
        flags.word_size = _asgnret_1.r1;
        conv_ok = _asgnret_1.r2;
        i = (i + 1);
        if((!conv_ok)) {
          flags.error = true;
        }
      }
    } else if(nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-o", 2}))) {
      if((i == nelua_sequence_string__1___len((&nelua_arg)))) {
        flags.error = true;
      } else {
        flags.output = (*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize((i + 1)))));
        i = (i + 1);
      }
    } else if(nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-no-stack-init", 14}))) {
      flags.set_stack = false;
    } else if(nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-no-prefix", 10}))) {
      flags.no_prefix = true;
    } else if(nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-set-stack-to", 13}))) {
      if((i == nelua_sequence_string__1___len((&nelua_arg)))) {
        flags.error = true;
      } else {
        nlmulret_nlint64_nlboolean _asgnret_2 = utils_check_integer((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize((i + 1))))));
        flags.stack_value = _asgnret_2.r1;
        conv_ok = _asgnret_2.r2;
        i = (i + 1);
        if((!conv_ok)) {
          flags.error = true;
        }
      }
    } else if(nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-start-addr", 11}))) {
      if((i == nelua_sequence_string__1___len((&nelua_arg)))) {
        flags.error = true;
      } else {
        nlmulret_nlint64_nlboolean _asgnret_3 = utils_check_integer((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize((i + 1))))));
        flags.start_addr = _asgnret_3.r1;
        conv_ok = _asgnret_3.r2;
        i = (i + 1);
        if((!conv_ok)) {
          flags.error = true;
        }
      }
    } else if(nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-ignore-start", 13}))) {
      flags.ignore_start = true;
    } else if(nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i)))), ((nlstring){(uint8_t*)"-label-dump", 11}))) {
      flags.label_dump = true;
    } else {
      flags.input = (*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), nelua_assert_narrow_nlint64_nlusize(i))));
    }
    i = (i + 1);
  }
  return flags;
}
void main_check_flags_ok(main_arg_flags flags) {
  if(flags.error) {
    nelua_filestream_write_4((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, invalid arguments.\n", 26}), ((nlstring){(uint8_t*)nelua_strlit_1, 893}));
    nelua_os_exit_1(-1);
  }
  if(flags.help) {
    nelua_filestream_write_1((&nelua_io_stdout), ((nlstring){(uint8_t*)nelua_strlit_1, 893}));
    nelua_os_exit_1(0);
  }
  if((nelua_nlstring___eq(flags.input, ((nlstring){(uint8_t*)"", 0})) || nelua_nlstring___eq(flags.output, ((nlstring){(uint8_t*)"", 0})))) {
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, input or output file not specified.\n", 43}));
    nelua_os_exit_1(-1);
  }
  if((!((((flags.word_size == 8) || (flags.word_size == 16)) || (flags.word_size == 32)) || (flags.word_size == 64)))) {
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)nelua_strlit_2, 80}));
    nelua_os_exit_1(-1);
  }
}
nlstring main_make_start_runtime(main_arg_flags flags) {
  int64_t word_size = flags.word_size;
  nelua_stringbuilderT builder = (nelua_stringbuilderT){0};
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"@define @align_word 0\n", 22}));
  if((word_size == 8)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)";Note: no need for 8 as it would always be alligned.\n", 53}));
  } else if((word_size == 16)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"    @align 2\n", 13}));
  } else if((word_size == 32)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"    @align 4\n", 13}));
  } else if((word_size == 64)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"    @align 8\n", 13}));
  } else {
    nelua_panic_string(((nlstring){(uint8_t*)"Invalid argument for make_start_runtime.\n", 41}));
  }
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"@end\n", 5}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"@define @set_default_sr 0\n", 26}));
  if((word_size == 8)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"    set 7\n", 10}));
  } else if((word_size == 16)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"    set 5\n", 10}));
  } else if((word_size == 32)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"    set 3\n", 10}));
  } else {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"    set 1\n", 10}));
  }
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"@end\n", 5}));
  if((word_size == 64)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)nelua_strlit_3, 119}));
  } else {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"@define @set_wordsize_byte 0\n    set ", 37}));
    nelua_stringbuilderT_write_1((&builder), nelua_tostring_2(nelua_tointeger_2((word_size / (double)8), NELUA_NIL)));
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n@end\n", 6}));
  }
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)nelua_strlit_4, 2412}));
  if((!flags.no_prefix)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"@rawbytes 41 53 52 4d\n", 22}));
  }
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"@set_default_sr\ncpy SR\n", 23}));
  if(flags.set_stack) {
    if((flags.stack_value < 0)) {
      nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"setlab __code_end__\ncpy SP\n", 27}));
    } else {
      nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"setr SP ", 8}));
      nelua_stringbuilderT_write_1((&builder), nelua_tostring_2(flags.stack_value));
      nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n", 1}));
    }
  }
  if((!flags.ignore_start)) {
    nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"goto start\n", 11}));
  }
  return nelua_stringbuilderT_promote((&builder));
}
int64_t nelua_assert_narrow_nlfloat64_nlint64(double x) {
  if(NELUA_UNLIKELY((int64_t)(x) != x)) {
    nelua_panic_cstring("narrow casting from float64 to int64 failed");
  }
  return (int64_t)x;
}
assembler_error_t main_reflet_fpu_asm_main(void) {
  main_arg_flags flags = main_parse_args();
  main_check_flags_ok(flags);
  nlmulret_nelua_vector_uint8__assembler_error_t _asgnret_1 = assembler_assemble(flags.input, main_make_start_runtime(flags), ((nlstring){(uint8_t*)nelua_strlit_5, 95}), nelua_assert_narrow_nlfloat64_nlint64((flags.word_size / (double)8)), flags.start_addr, flags.label_dump);
  nelua_vector_uint8_ machine_code = _asgnret_1.r1;
  assembler_error_t asm_error = _asgnret_1.r2;
  if((asm_error != 0)) {
    return asm_error;
  }
  nlmulret_nelua_filestream_nlstring_nlint64 _asgnret_2 = nelua_io_open_1(flags.output, ((nlstring){(uint8_t*)"w", 1}));
  nelua_filestream f = _asgnret_2.r1;
  nlstring msg = _asgnret_2.r2;
  int64_t err = _asgnret_2.r3;
  if((err != 0)) {
    nelua_filestream_write_5((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, unable to open ", 22}), flags.output, ((nlstring){(uint8_t*)" .\n", 3}), msg, ((nlstring){(uint8_t*)"\n", 1}));
    return 2;
  }
  for(intptr_t i = 0, _end = nelua_vector_uint8____len((&machine_code)); i < _end; i += 1) {
    nelua_filestream_write_1((&f), nelua_nlstring_char_1((*(uint8_t*)nelua_assert_deref(nelua_vector_uint8____atindex((&machine_code), nelua_assert_narrow_nlisize_nlusize(i))))));
  }
  nelua_filestream_close((&f));
  return 0;
}
int nelua_main(int argc, char** argv) {
  nelua_argc = argc;
  nelua_argv = argv;
  nelua_require_io_cached(NELUA_NIL);
  nelua_require_arg(NELUA_NIL);
  nelua_require_utils_cached(NELUA_NIL);
  nelua_require_assembler(NELUA_NIL);
  main_exit_code = main_reflet_fpu_asm_main();
  nelua_os_exit_1((int64_t)main_exit_code);
  return 0;
}
